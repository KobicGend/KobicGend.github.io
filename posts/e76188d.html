<!DOCTYPE html><html lang="zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>XCPC wiki - 建模 | 小明の雜貨屋</title><meta name="author" content="小明同學"><meta name="copyright" content="小明同學"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="二分图 Stop the Castle There are n castles and m obstacles on a chessboard. Each castle or obstacle occupies exactly one cell and all occupied cells are distinct. Two castles can attack each other, if th"><meta property="og:type" content="article"><meta property="og:title" content="XCPC wiki - 建模"><meta property="og:url" content="http://kobicgend.top/posts/e76188d.html"><meta property="og:site_name" content="小明の雜貨屋"><meta property="og:description" content="二分图 Stop the Castle There are n castles and m obstacles on a chessboard. Each castle or obstacle occupies exactly one cell and all occupied cells are distinct. Two castles can attack each other, if th"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="http://kobicgend.top/img/avatar.webp"><meta property="article:published_time" content="2025-01-24T14:05:00.000Z"><meta property="article:modified_time" content="2025-01-24T14:05:00.000Z"><meta property="article:author" content="小明同學"><meta property="article:tag" content="ACM"><meta property="article:tag" content="算法"><meta property="article:tag" content="筆記"><meta property="article:tag" content="圖論"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://kobicgend.top/img/avatar.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "XCPC wiki - 建模",
  "url": "http://kobicgend.top/posts/e76188d.html",
  "image": "http://kobicgend.top/img/avatar.webp",
  "datePublished": "2025-01-24T14:05:00.000Z",
  "dateModified": "2025-01-24T14:05:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "小明同學",
      "url": "http://kobicgend.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.webp"><link rel="canonical" href="http://kobicgend.top/posts/e76188d.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const n=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:n}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:n}=JSON.parse(t);if(!(Date.now()>n))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,n)=>{const a=document.createElement("script");a.src=e,a.async=!0,Object.entries(t).forEach(([e,t])=>a.setAttribute(e,t)),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||o()},a.onerror=n,document.head.appendChild(a)}),getCSS:(e,t)=>new Promise((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||o()},a.onerror=n,document.head.appendChild(a)}),addGlobalFn:(e,t,o=!1,n=window)=>{if(e.startsWith("pjax"))return;const a=n.globalFn||{};a[e]=a[e]||{},a[e][o||Object.keys(a[e]).length]=t,n.globalFn=a}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","undefined")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","undefined")};btf.activateDarkMode=t,btf.activateLightMode=o;const n=e.get("theme");"dark"===n?t():"light"===n&&o();const a=e.get("aside-status");void 0!==a&&document.documentElement.classList.toggle("hide-aside","hide"===a);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"複製成功",error:"複製失敗",noSupport:"瀏覽器不支援"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"剛剛",min:"分鐘前",hour:"小時前",day:"天前",month:"個月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"載入更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!0,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"XCPC wiki - 建模",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/fonts.css"><link rel="stylesheet" href="/css/title.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/masktag.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/all.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">載入中...</div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o=()=>{e.style.overflow="",d.classList.add("loaded")},l=()=>{e.style.overflow="hidden",d.classList.remove("loaded")};l(),window.addEventListener("load",o)})()</script><div id="web_bg" style="background-image:url(/img/background.webp)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">381</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">23</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-book"></i> <span>記事簿</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/diary/diary-stz/"><i class="fa-fw fas fa-book"></i> <span>《中外历史纲要》</span></a></li><li><a class="site-page child" href="/categories/%E6%97%A5%E8%A8%98/%E4%B8%BB%E6%9C%BA%E8%A8%BB%E8%A8%98/"><i class="fa-fw fa fa-book"></i> <span>《主机註記》</span></a></li><li><a class="site-page child" href="/diary/hutaolinriji/"><i class="fa-fw fa fa-book"></i> <span>楜桃林日記</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-open"></i> <span>筆記本</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/e7eea71f.html"><i class="fa-fw fa fa-quran"></i> <span>XCPC</span></a></li><li><a class="site-page child" href="/notes/"><i class="fa-fw fa fa-tanakh"></i> <span>大學筆記</span></a></li><li><a class="site-page child" href="/notes/"><i class="fa-fw fa fa-tanakh"></i> <span>其它筆記</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-palette"></i> <span>作品集</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E4%BD%9C%E5%93%81/%E5%BE%AE%E4%BF%A1%E5%85%AC%E7%9C%BE%E8%99%9F/"><i class="fa-fw fa fa-radio"></i> <span>CUC-Radio</span></a></li><li><a class="site-page child" href="/posts/667c5340.html"><i class="fa-fw fa fa-stamp"></i> <span>篆刻作品展</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-toolbox"></i> <span>工具箱</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Music/"><i class="fa-fw fas fa-music"></i> <span>Music</span></a></li><li><a class="site-page child" href="/categories/Poetry/"><i class="fa-fw fas fa-guitar"></i> <span>詩詞</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i> <span>更多</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/project/map/index.html"><i class="fa-fw fas fa-map"></i> <span>旅遊足跡</span></a></li><li><a class="site-page child" href="/posts/c096c313.html"><i class="fa-fw fas fa-subway"></i> <span>地鐵圖</span></a></li><li><a class="site-page child" href="/ovo/eikon"><i class="fa-fw fas fa-wind"></i> <span>賽博空調</span></a></li><li><a class="site-page child" href="/ovo/tabe"><i class="fa-fw fas fa-utensils"></i> <span>中午吃什么</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>好盆友</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i> <span>關於小明</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/index.webp)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">小明の雜貨屋</span></a><a class="nav-page-title" href="/"><span class="site-name">XCPC wiki - 建模</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-book"></i> <span>記事簿</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/diary/diary-stz/"><i class="fa-fw fas fa-book"></i> <span>《中外历史纲要》</span></a></li><li><a class="site-page child" href="/categories/%E6%97%A5%E8%A8%98/%E4%B8%BB%E6%9C%BA%E8%A8%BB%E8%A8%98/"><i class="fa-fw fa fa-book"></i> <span>《主机註記》</span></a></li><li><a class="site-page child" href="/diary/hutaolinriji/"><i class="fa-fw fa fa-book"></i> <span>楜桃林日記</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-open"></i> <span>筆記本</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/e7eea71f.html"><i class="fa-fw fa fa-quran"></i> <span>XCPC</span></a></li><li><a class="site-page child" href="/notes/"><i class="fa-fw fa fa-tanakh"></i> <span>大學筆記</span></a></li><li><a class="site-page child" href="/notes/"><i class="fa-fw fa fa-tanakh"></i> <span>其它筆記</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-palette"></i> <span>作品集</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E4%BD%9C%E5%93%81/%E5%BE%AE%E4%BF%A1%E5%85%AC%E7%9C%BE%E8%99%9F/"><i class="fa-fw fa fa-radio"></i> <span>CUC-Radio</span></a></li><li><a class="site-page child" href="/posts/667c5340.html"><i class="fa-fw fa fa-stamp"></i> <span>篆刻作品展</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-toolbox"></i> <span>工具箱</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Music/"><i class="fa-fw fas fa-music"></i> <span>Music</span></a></li><li><a class="site-page child" href="/categories/Poetry/"><i class="fa-fw fas fa-guitar"></i> <span>詩詞</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i> <span>更多</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/project/map/index.html"><i class="fa-fw fas fa-map"></i> <span>旅遊足跡</span></a></li><li><a class="site-page child" href="/posts/c096c313.html"><i class="fa-fw fas fa-subway"></i> <span>地鐵圖</span></a></li><li><a class="site-page child" href="/ovo/eikon"><i class="fa-fw fas fa-wind"></i> <span>賽博空調</span></a></li><li><a class="site-page child" href="/ovo/tabe"><i class="fa-fw fas fa-utensils"></i> <span>中午吃什么</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>好盆友</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i> <span>關於小明</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">XCPC wiki - 建模</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2025-01-24T14:05:00.000Z" title="發表於 2025-01-24 22:05:00">2025-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-01-24T14:05:00.000Z" title="更新於 2025-01-24 22:05:00">2025-01-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AD%86%E8%A8%98/">筆記</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AD%86%E8%A8%98/XCPCwiki/">XCPCwiki</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">總字數:</span><span class="word-count">8.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀時間:</span><span>38分鐘</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="二分图">二分图</h2><h3 id="Stop-the-Castle"><a target="_blank" rel="noopener" href="https://codeforces.com/gym/526653/problem/H">Stop the Castle</a></h3><p>There are n castles and m obstacles on a chessboard. Each castle or obstacle occupies exactly one cell and all occupied cells are distinct. Two castles can attack each other, if they’re on the same row or the same column, and there are no obstacles or other castles between them. Find a way to place the minimum number of additional obstacles onto the chessboard, so that no two castles can attack each other.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; X, Y;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">    X[x].<span class="built_in">emplace_back</span>(y, <span class="number">1</span>);</span><br><span class="line">    Y[y].<span class="built_in">emplace_back</span>(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">    X[x].<span class="built_in">emplace_back</span>(y, <span class="number">0</span>);</span><br><span class="line">    Y[y].<span class="built_in">emplace_back</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; boy, girl;</span><br><span class="line"><span class="type">bool</span> ugly = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, vec] : X) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; vec.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [y1, op1] = vec[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">auto</span>&amp; [y2, op2] = vec[j];</span><br><span class="line">        <span class="keyword">if</span> (op1 &amp;&amp; op2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y1 + <span class="number">1</span> == y2) ugly = <span class="number">1</span>;</span><br><span class="line">            boy.<span class="built_in">push_back</span>(&#123; x, y1, y2 &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [y, vec] : Y) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; vec.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [x1, op1] = vec[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">auto</span>&amp; [x2, op2] = vec[j];</span><br><span class="line">        <span class="keyword">if</span> (op1 &amp;&amp; op2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x1 + <span class="number">1</span> == x2) ugly = <span class="number">1</span>;</span><br><span class="line">            girl.<span class="built_in">push_back</span>(&#123; y, x1, x2 &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n = boy.<span class="built_in">size</span>(), m = girl.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">E</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; [x, y1, y2] = boy[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; m; ++v) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [y, x1, x2] = girl[v];</span><br><span class="line">        <span class="keyword">if</span> (x1 &lt; x &amp;&amp; x &lt; x2 &amp;&amp; y1 &lt; y &amp;&amp; y &lt; y2) &#123;</span><br><span class="line">            E[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ugly) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">npy</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> u) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : E[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[v] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (npy[v] == <span class="number">-1</span> || <span class="built_in">self</span>(npy[v])) &#123;</span><br><span class="line">                npy[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">happy</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; m; ++v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (npy[v] != <span class="number">-1</span>) &#123;</span><br><span class="line">        happy[npy[v]] = <span class="literal">true</span>;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(boy[npy[v]][<span class="number">0</span>], girl[v][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [y, x1, x2] = girl[v];</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(x1 + x2 &gt;&gt; <span class="number">1</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!happy[u]) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [x, y1, y2] = boy[u];</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(x, y1 + y2 &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y] : res) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CF1634E-Fair-Share"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1634/problem/E">CF1634E. Fair Share</a></h3><blockquote><p>Even a cat has things it can do that AI cannot. — Fei-Fei Li</p></blockquote><p><strong>题意</strong> 给定 $m$ 个数组，第 $i$ 个数组包含 $n_i$ 个整数，保证 $n_i$ 是偶数。另外还有两个初始为空的可重集 $L,R$，将第 $i$ 个数组中的所有数当中选出 $\frac{n_i}{2}$ 个数放入 $L$ 中，另一半则放入 $R$ 中。问能否有一种方案满足 $L=R$。数据范围：$1\leqslant m, n_i\leqslant2\times 10^5,\ 1\leqslant a_j\leqslant 10^9$。</p><p><strong>思路</strong> 两种建模法：</p><ol><li>建二分图。$m$ 个数组作左部点，数组的每个值作右部点，键与值连边。根据题意，合法的图满足，每个左部点的度数为偶数，右部点的度数也为偶数。因此这个二分图存在欧拉回路则合法。</li><li>建普通图。每个数组奇偶项连边，每个值出现的第奇偶次连边。这个图是二分图则合法。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; vec;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(<span class="number">200000</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">n</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    cin &gt;&gt; n[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n[i]; j++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            g[tot].<span class="built_in">push_back</span>(tot - <span class="number">1</span>);</span><br><span class="line">            g[tot - <span class="number">1</span>].<span class="built_in">push_back</span>(tot);</span><br><span class="line">        &#125;</span><br><span class="line">        vec[x].<span class="built_in">push_back</span>(tot);</span><br><span class="line">        tot++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bipartite = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : vec) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v.<span class="built_in">size</span>() % <span class="number">2</span>) bipartite = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; v.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        g[v[i]].<span class="built_in">push_back</span>(v[i - <span class="number">1</span>]);</span><br><span class="line">        g[v[i - <span class="number">1</span>]].<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(tot, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; tot; ++s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c[s] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    c[s] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                c[v] = <span class="number">1</span> ^ c[u];</span><br><span class="line">                Q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c[v] == c[u]) &#123;</span><br><span class="line">                bipartite = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bipartite) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n[i]; j++) &#123;</span><br><span class="line">            cout &lt;&lt; (c[tot++] == <span class="number">1</span> ? <span class="string">&quot;L&quot;</span> : <span class="string">&quot;R&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一笔画">一笔画</h2><h3 id="CF1981D-Turtle-and-Multiplication"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1981/problem/D">CF1981D. Turtle and Multiplication</a></h3><p><strong>题意</strong> 给定 $n$，构造一个长度为 $n$ 的整数数列 $a$，满足：</p><ul><li>$1 \leqslant a_i \leqslant 3 \times 10^5$；</li><li>$\forall 1 \leqslant i&lt;j\leqslant n-1$，有 $a_i \cdot a_{i + 1} \neq a_j \cdot a_{j + 1}$，即相邻两项之积两两互不相等；</li><li>最小化数列中的不同元素个数。</li></ul><p>数据范围：$2 \leqslant n \leqslant 10^6$。</p><p><strong>思路</strong> 取 $a_{i}$ 为 <strong>素数</strong> 。这是由于 $a_i \cdot a_{i + 1} = a_j \cdot a_{j + 1}$ 的 <strong>必要条件</strong> 是无序对 $(a_i, a_{i + 1})$ 和无序对 $(a_j, a_{j + 1})$ 相同。而如果 $a_i$ 都取素数，这个必要条件就会变成 <strong>充要条件</strong>。</p><p>如果我们把 $(a_i, a_{i + 1})$ 看成一条边，问题转化为找到点数最少的无向完全图（每个点还有一个自环），使得这个完全图存在一条经过 $n - 1$ 条边且不经过重复边的路径。</p><p>考虑若完全图点数确定，我们如何计算这个完全图的最长不经过重复边的路径长度。设完全图点数为 $m$，若 $m$ 是奇数，那么每个点的度数都是偶数，所以这个图存在欧拉路径，路径长度即为边数，其等于 $\frac{m(m - 1)}{2}+m=\frac{m(m + 1)}{2}$；若 $m$ 是偶数，那么每个点的度数都是奇数，我们需要删除一些边使得这个图存在欧拉路径。容易发现一条边最多使奇度数点的数量减少 $2$，所以我们至少需要删除 $\frac{m}{2} - 1$ 条边，删除 $(2, 3), (4, 5), \ldots, (m - 2, m - 1)$ 这些边即可，路径长度为 $\frac{m(m - 1)}{2} - \frac{m}{2} + 1 + m = \frac{m^2}{2} + 1$。</p><p>当 $n = 10^6$ 时最小的 $m$ 是 $1415$，第 $1415$ 小的质数是 $11807$，符合 $a_i \leqslant 3 \cdot 10^5$。</p><p>时间复杂度 $\Theta(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">3e6</span> + <span class="number">8</span>;</span><br><span class="line"><span class="type">bool</span> isntPrime[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">beforeT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isntPrime[i]) prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : prime) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">            isntPrime[p * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isntPrime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num - <span class="number">1</span> &gt; ((m &amp; <span class="number">1</span>) ? (m * (m + <span class="number">1</span>) / <span class="number">2</span>) : (m * m / <span class="number">2</span> + <span class="number">1</span>)))</span><br><span class="line">        ++m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">E</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; i + <span class="number">1</span> == j) <span class="keyword">continue</span>;</span><br><span class="line">            E[i].<span class="built_in">emplace_back</span>(j, ++id);</span><br><span class="line">            E[j].<span class="built_in">emplace_back</span>(i, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(id + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> u) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!E[u].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [v, id] = E[u].<span class="built_in">back</span>();</span><br><span class="line">            E[u].<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (vis[id]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[id] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">self</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, prime[path[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集">并查集</h2><h3 id="VJspr1G-Chemical-table"><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1013/D">VJspr1G - Chemical table</a></h3><p><strong>题意</strong> 给出一个 $n \times m$ 矩形，可以在格点上放置点，对于任意两行两列，如果相交的四个格子中有三个格子有点，那么第四个格子将自动放置一个点。起初已经有一些点，求最小手动添加点的次数，使得整个矩形内的格子都有点。</p><p><strong>思路</strong> 用两个并查集分别存储行和列的连通状态，如果一行上有多个点，就将这些点所在的列连通，同理将每一列的几个点所在的行连通，统计行的连通图总数 $S_1$ 以及列的连通图总数 $S_2$，将所有连通图连通的最小边数是 $\max{S_1,S_2}-1$。</p><blockquote><p>值得思考的是，取最大值的原理是什么？</p><p>如样例二，竖着看是三个连通图，横着数是一个，那最终是三个连通图。这几个样例似乎都没问题，但直觉上有点面向样例编程了，得找个反例。</p><p>事实上，将点合并这个过程是正确的，但是没有点的部分会出现问题。比如 $2 \times 2$ 的空格，正确答案是至少需要 $3$ 步，但依此方法，竖着数是 $2$ 个，横着数也是 $2$ 个，答案是 $1$ 步。</p><p>因此上述思路并不合理。</p></blockquote><p>回到原问题，所求的是将所有连通图连通的最小边数，首先应思考，题给数据是如何连通的？不难发现，每一个点的作用实际上是将该行和该列连通，这也是“第四个格子将自动放置一个点”的原理。一句话概括，<strong>将行列视为点，将点视为边</strong>。因此，我们创建一个 $n+m$ 大小的并查集，前 $n$ 个元素代表行，后 $m$ 个元素代表列，如果 $(x,y)$ 有点，则连接 $x$ 行（即 $x$）和 $y$ 列（即 $y+n$）这两个元素，统计连通图总数 $S$，结果是 $S-1$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line"><span class="function">DSU <span class="title">dsu</span><span class="params">(n + m)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">    dsu.<span class="built_in">uno</span>(x, y + n);  <span class="comment">// WA</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++i) &#123;</span><br><span class="line">    res += dsu.<span class="built_in">find</span>(i) == i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="置换环">置换环</h2><p>对于一个排列 $p$，若连有向边 $i\to p_{i}$，则整张图由若干个 <strong>环 (cycle)</strong>（包括长度为 $1$ 的）组成，每个环称作 <strong>置换环</strong>。</p><p>每个置换环中，数组排序元素间所需 <strong>最小交换次数</strong> 为环上元素数量 $- 1$。因此数组排序的最小交换次数为数组长度 $-$ 置换环数量。如果只允许交换相邻项（冒泡排序），则最小交换次数等于逆序对的数量。</p><p>用 while 循环找置换环，时间复杂度 $\Theta(n)$。</p><p><strong>例 1</strong>（理解置换环）给定一长为 $n$ 的字符串 $s$ 与 $1\sim n$ 的排列 $p$。定义 $s^0=s,s^k_i=s^{k-1}_{p_i}$。求最小的 $k&gt;0$ 使 $s^k=s$。$n \leqslant 200$。</p><p>模拟置换的过程即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; p[i];</span><br><span class="line">    p[i]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> u = i;</span><br><span class="line">    string cyc;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cyc += s[u];</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        u = p[u];</span><br><span class="line">    &#125; <span class="keyword">while</span> (u != i);</span><br><span class="line">    <span class="keyword">auto</span> ncyc = cyc;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        t++;</span><br><span class="line">        ncyc = ncyc.<span class="built_in">substr</span>(<span class="number">1</span>) + ncyc[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">while</span> (ncyc != cyc);</span><br><span class="line">    res = <span class="built_in">lcm</span>(res, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>例 2</strong> 给定一个排列 $p$，每次选择四个位置任意交换其中的元素，求排序的最小交换次数。(2024 牛客多校 4C - Sort4, [[…/contests/2024 牛客多校 /2024-07-25：2024 牛客暑期多校训练营 4#C - Sort4 (37)|2024-07-25：2024 牛客暑期多校训练营 4]])</p><p>考虑每个置换环，设环的长度为 $s$：</p><ul><li>$s=3,4$ 可以一次排好；</li><li>两个 $s=2$ 的环可以一次排好；</li><li>对于 $s&gt;4$ 的环，每次操作可以排好其中三个元素，环长变为 $s-3$，记录有多少个环最终长度为 $2$。</li></ul><p><strong>例 3</strong> 给定一个排列 $p$，每次可交换排列中的任意两个数，求使得排列中有且仅有一个逆序对的最小交换次数。(<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1768/problem/D">CF1768D. Lucky Permutation</a>)</p><p>考虑每个置换环，如果存在相邻元素，那么可以少交换一次，否则需要多交换一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; p[i];</span><br><span class="line">    p[i]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; cycs;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> u = i;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cyc;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cyc.<span class="built_in">push_back</span>(u);</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        u = p[u];</span><br><span class="line">    &#125; <span class="keyword">while</span> (u != i);</span><br><span class="line">    cycs.<span class="built_in">push_back</span>(cyc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; cyc : cycs) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(cyc.<span class="built_in">begin</span>(), cyc.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; cyc.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        flag |= cyc[j - <span class="number">1</span>] == cyc[j] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res += cyc.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (res + <span class="number">1</span> - <span class="number">2</span> * flag) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>例 4</strong> 给定一个排列 $p$，求一个排列 $q$，满足 $q^{2}=p$（即 $q_{q_{i}}=p_{i}$）。(<a target="_blank" rel="noopener" href="https://codeforces.com/contest/612/problem/E">CF612E. Square Root of Permutation</a>)</p><p>考虑每个置换环，如果环长为奇数，可构造五角星，如果是偶数，一个环内部无解，需要用两个大小相同的环构造，因此如果某个环长的环有奇数个则无解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; p[i];</span><br><span class="line">    p[i]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">cycs</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> u = i;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cyc;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cyc.<span class="built_in">push_back</span>(u);</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        u = p[u];</span><br><span class="line">    &#125; <span class="keyword">while</span> (u != i);</span><br><span class="line">    cycs[cyc.<span class="built_in">size</span>()].<span class="built_in">push_back</span>(cyc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> siz = <span class="number">1</span>; siz &lt;= n; siz++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (siz &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; cyc : cycs[siz]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; siz; i++) &#123;</span><br><span class="line">                res[cyc[i]] = cyc[(i + (siz + <span class="number">1</span>) / <span class="number">2</span>) % siz];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cycs[siz].<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; cycs[siz].<span class="built_in">size</span>(); k += <span class="number">2</span>) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;&amp; L = cycs[siz][k - <span class="number">1</span>], &amp;R = cycs[siz][k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; siz; i++) &#123;</span><br><span class="line">            res[L[i]] = R[i];</span><br><span class="line">            res[R[i]] = L[(i + <span class="number">1</span>) % siz];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cout &lt;&lt; ++res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例 5</strong> 给定两个排列 $a,b$，求一个排列满足 $a_{i}=p_{a_{i}},\ b_{i}=p_{b_{i}}$，最大化 $\sum|a_{i}-b_{i}|$。(<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1678/problem/E">CF1978E. Tokitsukaze and Two Colorful Tapes</a>)</p><p>连边 $a_{i}\to b_{i}$，问题转化为：给环重新赋值，最大化环上相邻两个数差的绝对值之和。</p><p>猜测大小交替，手玩发现先最大再次大是没有影响的，也就是说可以选择任意大于 $\cfrac{n}{2}$ 的作为大数，任意小于 $\cfrac{n}{2}$ 的作为小数，如此交替。这确实是对的，但是有个问题，奇环如何处理？大小大是不行的，因为最后一个无论填什么对答案都没有影响，所以应该留到最后。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n)</span>, <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    x--;</span><br><span class="line">    pos[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    x--;</span><br><span class="line">    p[i] = pos[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; cycs;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> u = i;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cyc;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cyc.<span class="built_in">push_back</span>(u);</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        u = p[u];</span><br><span class="line">    &#125; <span class="keyword">while</span> (u != i);</span><br><span class="line">    cycs.<span class="built_in">push_back</span>(cyc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> min = <span class="number">1</span>, max = n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; cyc : cycs) &#123;</span><br><span class="line">    <span class="type">int</span> siz = cyc.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; siz - siz % <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        ans[cyc[i]] = i &amp; <span class="number">1</span> ? min++ : max--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ans[i] == <span class="number">-1</span>) ans[i] = min++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res += <span class="built_in">abs</span>(ans[i] - ans[p[i]]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>例 6</strong> 给定 $n$ 个二元组 $(a_{i},b_{i})$，可以按任意次序重新排序，问能否使得排序后数组 $\lbrace a \rbrace$ 的逆序对数和 $\lbrace b \rbrace$ 的逆序对数相同，给出方案。(<a target="_blank" rel="noopener" href="https://codeforces.com/gym/105383/problem/C">2024 ICPC 台湾 C. Cards</a>)</p><p>将每个置换环排在一起，每个环内部按环的顺序排列。如果环长为奇数，选取中位数作为 $a$ 的起点，由于内部按环的顺序排列，故同时这个数也是 $b$ 的终点，不难证明这部分两数组的逆序对数相同。如果环长为偶数，两个数组的逆序对数之差总是为奇数，因此如果有奇数个环长为偶数的环则无解，构造方式是对于两个环，一个选取中间较小的数为起点，另一个选取中间较大的数为起点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n)</span>, <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    x--;</span><br><span class="line">    pos[x] = i;</span><br><span class="line">    a[i].first = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    x--;</span><br><span class="line">    p[i] = pos[x];</span><br><span class="line">    a[i].second = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; cycs;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> u = i;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; cyc;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cyc.<span class="built_in">push_back</span>(a[u]);</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        u = p[u];</span><br><span class="line">    &#125; <span class="keyword">while</span> (u != i);</span><br><span class="line">    cycs.<span class="built_in">push_back</span>(cyc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; cyc : cycs) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m = cyc.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">0</span>) cnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> tmp = cyc;</span><br><span class="line">    <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> mid = tmp[(m - (cnt % <span class="number">2</span>)) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cyc[i] == mid) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                res[tot++] = cyc[(i + j) % m];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ++res[i].first &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ++res[i].second &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="蝌蚪图">蝌蚪图</h2><h3 id="CF1787D-Game-on-Axis"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1787/problem/D">CF1787D. Game on Axis</a></h3><p><strong>思路</strong> 有一个包含 $n$ 个点的棋盘，第 $i$ 个点上有数字 $a_i$，初始棋子在点 $1$。当棋子在点 $i$ 时：</p><ul><li>若 $1\le i\le n$，则你会跳到点 $i+a_i$ ($-n \leqslant a_{i} \leqslant n$)；</li><li>否则游戏结束。</li></ul><p>在游戏开始前，你可以选择一对 $x$ 和 $y$ ($1 \leqslant x \leqslant n,-n \leqslant y \leqslant n$)，并将 $a_x$ 赋值为 $y$。请求出这样的 $(x,y)$ 的对数使得可以在有限步内结束游戏。</p><p><strong>思路</strong> 连边 $i\leftarrow i+a_{i}$，不在 $1\sim n$ 范围内的点合并为一个超级点 $0$。</p><p>分析这张图。每个点的入度一定为 $1$，而且总共只有 $n$ 条边，因此对于每个连通块，要么是有向树，要么是一个有向环带若干个树尾巴（下称蝌蚪），边的方向是从根到叶。</p><p>这就有两种情况，起点要么在蝌蚪上，要么不在。对于前者，合法的方法数是从蝌蚪路径上任意一个点跳到树上；对于后者，不合法的方法数是树的叶连接了根，或者从路径上任意一个点跳到蝌蚪上。</p><p>样例较弱，推式子需细心。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">E</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> v = u + x;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; n || v &lt; <span class="number">1</span>) v = <span class="number">0</span>;</span><br><span class="line">    E[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    p[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">siz</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> u) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : E[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">self</span>(v);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="built_in">count</span>(vis.<span class="built_in">begin</span>(), vis.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (vis[<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (u) &#123;</span><br><span class="line">        ans += siz[u] + cnt;</span><br><span class="line">        u = p[u];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="number">1ll</span> * n * (<span class="number">2</span> * n + <span class="number">1</span>) - ans;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (u &amp;&amp; vis[u] != <span class="number">2</span>) &#123;</span><br><span class="line">        vis[u] = <span class="number">2</span>;</span><br><span class="line">        ans += (<span class="number">2</span> * n + <span class="number">1</span>) - cnt;</span><br><span class="line">        u = p[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="2023-ICPC- 杭州 -H-Sugar-Sweet-II"><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104976/problem/H">2023 ICPC 杭州 H. Sugar Sweet II</a></h3><p><strong>题意</strong> $n$ 个数，有 $n$ 个事件，如果 $a_{i}&lt;a_{b_{i}}$，则 $a_{i}\leftarrow a_{i}+w_{i}$。事件随机顺序发生，问每个数的期望。([[…/contests/VP/2024-10-23-Autumn11-2023ICPC 杭州 |2024-10-23-Autumn11-2023ICPC 杭州]])</p><p><strong>思路</strong> 要求的就是每个事件发生的概率。事件只有三类：必然发生、必然不发生、发生当前仅当 $b_{i}$ 发生，对于第三者，其概率为 $\frac{1}{d_{i}!}$，其中 $d_{i}$ 表示有向图上最近的必然发生的事件对应的点（起点）的距离，用这些边建反图，从每个起点 DFS 处理出距离。</p><p>时间复杂度 $\Theta(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">3e5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll fac[N], ifac[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ifac[N - <span class="number">1</span>] = <span class="built_in">qpow</span>(fac[N - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">        ifac[i - <span class="number">1</span>] = ifac[i] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span>, <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; b[i];</span><br><span class="line">            b[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; w[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">op</span><span class="params">(n)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">E</span>(n);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[b[i]]) &#123;</span><br><span class="line">                st.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt; a[b[i]] + w[b[i]]) &#123;</span><br><span class="line">                E[b[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : st) &#123;</span><br><span class="line">            <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> u) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : E[u]) &#123;</span><br><span class="line">                    d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">self</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            d[s] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[b[i]]) &#123;</span><br><span class="line">                (res[i] += w[i]) %= mod;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt; a[b[i]] + w[b[i]]) &#123;</span><br><span class="line">                (res[i] += w[i] * ifac[d[i]]) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            (res[i] += a[i]) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分约束">差分约束</h2><p>给出一组包含 $m$ 个不等式，有 $n$ 个未知数的不等式组，形如<br>$$<br>\begin{cases}<br>x_{c_{1}} - x_{c’<em>{1}} + w</em>{1} \geqslant 0 \<br>x_{c_{2}} - x_{c’<em>{2}} + w</em>{2} \geqslant 0 \<br>\cdots \<br>x_{c_{m}} - x_{c’<em>{m}} + w</em>{m} \geqslant 0<br>\end{cases}<br>$$<br>求任意一组满足这个不等式组的解。</p><p>样例输入表示不等式组 $\begin{cases} x_{2} - x_{1} + 3 \geqslant 0 \ x_{3} - x_{2} - 2 \geqslant 0 \ x_{3} + x_{1} + 1 \geqslant 0 \end{cases}$，即 $\begin{cases} x_{2} + 3 \geqslant x_{1} \ x_{3} - 2 \geqslant x_{2} \ x_{3} + 1 \geqslant x_{1} \end{cases}$，输出表示 $\lbrace x_{1},x_{2},x_{3} \rbrace = \lbrace 0,-2,0 \rbrace$ 是一组可行的解：</p><table><thead><tr><th>Input</th><th>Output</th></tr></thead><tbody><tr><td>3 3<br>2 1 3<br>3 2 -2<br>3 1 1</td><td>0 -2 0</td></tr></tbody></table><p><strong>最短路求最大解</strong></p><ol><li>将每个不等式 $\boldsymbol{x_{u}+w \geqslant x_{v}}$ 转化为一条从 $u$ 走到 $v$，权为 $w$ 的 <strong>边</strong>。</li><li>建立一个 <strong>虚拟源点</strong>，使得该源点一定可以遍历到所有边。</li><li>跑一遍 <strong>负权图单源最短路 (Bellman - Ford)</strong>，时间复杂度 $\Theta(mn)$：<ul><li>如果存在负环，表明不等式出现矛盾，则原不等式组一定无解；</li><li>如果不存在负环，则 $d_{i}$ 就是原不等式组的一个可行解，也是 <strong>最大解</strong>。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N = n + <span class="number">1</span>;</span><br><span class="line">vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">E</span>(N);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    u--, v--;</span><br><span class="line">    E[u].<span class="built_in">push_back</span>(&#123; w, v &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    E[s].<span class="built_in">push_back</span>(&#123; <span class="number">0</span>, i &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> BellmanFord = [&amp;](<span class="type">int</span> s) &#123;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; <span class="built_in">vis</span>(N);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dis</span><span class="params">(N, inf)</span></span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; N; t++) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="number">0</span>;  <span class="comment">// 判断一轮循环过程中是否发生松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; N; u++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [w, v] : E[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                    dis[v] = dis[u] + w;  <span class="comment">// 松弛</span></span><br><span class="line">                    vis[v] = <span class="number">0</span>;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[u] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">return</span> dis;  <span class="comment">// 没有可以松弛的边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;ll&gt;();  <span class="comment">// N 轮后仍存在可以松弛的边 存在负环</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> dis = <span class="built_in">BellmanFord</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dis.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1\n\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">    cout &lt;&lt; dis[u] &lt;&lt; <span class="string">&quot; \n&quot;</span>[u == n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最长路求最小解</strong> 将不等式化为 $\boldsymbol{x_{u}+w \leqslant x_{v}}$，再修改最短路的松弛条件，得到 <strong>负权图单源最长路</strong> ，可求得 <strong>最小解</strong>。</p><table><thead><tr><th></th><th>最短路求最大解</th><th>最长路求最小解</th></tr></thead><tbody><tr><td>原始不等式</td><td>$x_{u}+w \geqslant x_{v}$（大于号）</td><td>$x_{u}+w \leqslant x_{v}$（小于号）</td></tr><tr><td>建边</td><td>从 $i$ 走到 $j$，权为 $w$ 的边</td><td>从 $i$ 走到 $j$，权为 $w$ 的边</td></tr><tr><td>初始化</td><td><code>dis[u] = inf</code></td><td><code>dis[u] = -inf</code></td></tr><tr><td>松弛条件</td><td><code>dis[v] &gt; dis[u] + w</code></td><td><code>dis[v] &lt; dis[u] + w</code></td></tr><tr><td>所得的解</td><td>最大解</td><td>最小解</td></tr></tbody></table><div style="page-break-after:always"></div><h2 id="杂题">杂题</h2><h3 id="CF1815C-Between"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1815/problem/C">CF1815C. Between</a></h3><p><strong>题意</strong> 给定整数 $n,m$ 和 $m$ 个整数数对 $(a_i,b_i)$，构造一个满足下列所有要求的序列：</p><ul><li>序列中的所有元素都应为 $1\sim n$ 的整数。</li><li>序列中恰好有一个元素为 $1$。</li><li>对于每个整数 $i(1\leq i\leq m)$，都满足序列中任意两个位置不同且值为 $a_i$ 的元素之间都存在至少一个值为 $b_i$ 的元素。</li><li>在满足上述三条要求的情况下序列长度尽可能长。</li></ul><p>如果满足上述前三条要求的序列可以达到任意大的长度，输出 <code>INFINITE</code>；否则输出 <code>FINITE</code>，并求出满足所有要求的任意一个序列。</p><p><strong>思路</strong> 连边 $b_{i}\to a_{i}$，从 1 开始 BFS，将同距离的存在一起，构造 4321432434。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">E</span>(n);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    u--, v--;</span><br><span class="line">    E[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : E[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[v] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">        Q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(n);</span><br><span class="line"><span class="type">bool</span> finite = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dis[i] == <span class="number">-1</span>) finite = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> vec[dis[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!finite) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;INFINITE\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FINITE\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> max = *<span class="built_in">max_element</span>(dis.<span class="built_in">begin</span>(), dis.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = max; j &gt;= i; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> u : vec[j]) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : res) &#123;</span><br><span class="line">        cout &lt;&lt; ++u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VJsum1K-Slime">VJsum1K. Slime</h3><p><strong>题意</strong> 在一条直线上有 $n$ 个史莱姆，每个史莱姆的坐标是 $x_i$，吞噬半径是 $r_i$。当一个史莱姆被吞噬时，就会发起攻击并吞噬其它史莱姆，如果另一个史莱姆所在位置 $x_j$ 满足 $|x_j-x_i| \leqslant r_i$ ，那么该史莱姆就会被吞噬。</p><p>如果第 $i$ 个史莱姆先发起攻击，记最终会被吞噬的史莱姆个数为 $f(i)$，现在，请你帮忙计算 $\sum \limits_{i=1}^n i\times f(i)$，答案对 $10^9 + 7$ 取模。</p><p>数据范围：$1\le n\leqslant 500000,\quad-10^{18}\leqslant x_{i}\leqslant 10^{18},\quad0\leqslant r_{i}\leqslant 2\times 10^{18}$。</p><p><strong>题意</strong> 有一定技巧，需要建模而实现简单，码量大但大部分是抄板子，写起来很爽的好题，此外本题有使用史莱姆算法的纯思维的解法。</p><p><strong>建模</strong> 若 $x$ 能直接吞噬 $y$，则在图上连边 $y\to x$，最终能吞噬的个数 $f(x)$ 即有向图上能到达 $x$ 的点数。</p><p><strong>连边</strong> 显然地，对于每个固定的 $x$，所有的 $y$ 都连续，也即是一个区间，记为 $[l,r]$，于是需要连边 $[l,r]\to x$。最坏情况下需要连 $n^{2}$ 条边，空间无法接受，但区间连边提示我们，可以 <strong>线段树优化建图</strong>。时间 $\Theta(n\log n)$，空间 $\Theta(n)$。</p><p>连边函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [l,r]向 x 连边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> p = <span class="number">1</span>, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> E[p].<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">addedge</span>(l, r, x, lson);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; r)  <span class="built_in">addedge</span>(l, r, x, rson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据线段树上的点的关系，子节点需要向父节点连边，这可以边建树边连：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建树 树上的边先连上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p = <span class="number">1</span>, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cl == cr) &#123;</span><br><span class="line">        w[p] = &#123; cl,cl &#125;;</span><br><span class="line">        rt[cl] = p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    E[ls].<span class="built_in">push_back</span>(p);</span><br><span class="line">    E[rs].<span class="built_in">push_back</span>(p);</span><br><span class="line">    <span class="built_in">build</span>(lson);</span><br><span class="line">    <span class="built_in">build</span>(rson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>求能到达的点数</strong> 按 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3387">缩点模板题</a> 的思路，跑肽键 (Tarjan) 和拓扑 (Topo)。时间 $\Theta(n+m)=\Theta(n)$（边数 $m=4n$），空间 $\Theta(n)$。</p><p>和模板题不同，由于线段树上的点不是并列关系，不能简单地将点权相加。</p><blockquote><p>比如把树上点 1 和 $\mathrm{ls}$ 缩成一个点，点 1 实际上是原图中的 $[1,n]$，是 $n$ 个点的集合，同理点 $\mathrm{ls}$ 是 $[1,n/2]$ 这 $n/2$ 个点的集合。如果简单粗暴地相加，得到的新点包将含 $1.5n$ 个点，显然不是我们想要的。</p></blockquote><p>因此用 $l,r$ 记录每个史莱姆能吞噬的范围，缩点就是把这些史莱姆揉在一起，新史莱姆能吞噬的范围就是 $[l_{\min},r_{\max}]$。</p><blockquote><p>还是刚才的例子，把 $[1,n]$ 和 $[1,n/2]$ 缩在一起，得到的是 $[1,n]$，实际上是 $n$ 个点。</p></blockquote><p>为了尽可能地减少代码修改，我们重新定义点权相加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1e9</span>, r;  <span class="comment">// 吞噬范围</span></span><br><span class="line">    node&amp; <span class="keyword">operator</span>+=(<span class="keyword">constexpr</span> node&amp; other) &#123;</span><br><span class="line">        l = <span class="built_in">min</span>(l, other.l);</span><br><span class="line">        r = <span class="built_in">max</span>(r, other.r);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; w[N];</span><br></pre></td></tr></table></figure><p>这样调用 <code>w[to]+=w[u]</code> 即可，保证新范围是 $[l_{\min},r_{\max}]$（即 <code>w[u].l</code> 到 <code>w[u].r</code>）的同时不需要修改肽键和拓扑里的任何代码。</p><p><strong>计算</strong> 现在得到了缩点后每个点 <code>u</code> 能到达的范围 <code>w[u].r - w[u].l + 1</code>，那对于原图点 <code>i</code>，在线段树上的点编号是 <code>rt[i]</code>，缩点后编号是 <code>fa[rt[i]]</code>，它能到达的范围就是 <code>w[fa[rt[i]]].r - w[fa[rt[i]]].l + 1</code>。按题设求和即可。</p><p>总的时间 $\Theta(n\log n)$，空间 $\Theta(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">8</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll Y = <span class="built_in">getchar</span>(), S = <span class="number">0</span>, C = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Y &gt; <span class="number">57</span> || Y &lt; <span class="number">48</span>) &#123; <span class="keyword">if</span> (Y == <span class="number">45</span>) C = <span class="number">-1</span>; Y = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (Y &lt;= <span class="number">57</span> &amp;&amp; Y &gt;= <span class="number">48</span>) &#123; S = (S &lt;&lt; <span class="number">3</span>) + (S &lt;&lt; <span class="number">1</span>) + Y - <span class="number">48</span>; Y = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">return</span> S * C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ---------------- 结构体 ----------------</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1e9</span>, r;  <span class="comment">// 吞噬范围 </span></span><br><span class="line">    node&amp; <span class="keyword">operator</span>+=(<span class="keyword">constexpr</span> node&amp; other) &#123;</span><br><span class="line">        l = <span class="built_in">min</span>(l, other.l);</span><br><span class="line">        r = <span class="built_in">max</span>(r, other.r);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; w[N];</span><br><span class="line"><span class="type">int</span> n, rt[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ---------------- 肽键和拓扑 都是抄板子 ----------------</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; E[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Etmp[N];</span><br><span class="line">node wtmp[N];</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], fa[N], unix;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachTarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++unix;       <span class="comment">// 记录 DFS 序</span></span><br><span class="line">    S.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="comment">// DP 更新 low[u]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : E[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) <span class="built_in">eachTarjan</span>(v), low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!fa[v]) low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// u 是 SCC 的根</span></span><br><span class="line">    <span class="keyword">if</span> (low[u] == dfn[u]) &#123;</span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            top = S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();    <span class="comment">// 出栈</span></span><br><span class="line">            fa[top] = u;               <span class="comment">// 记录 u 的子节点的根为 u</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (top != u);            <span class="comment">// 不断弹出直到根 u 弹出为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Tarjan</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[u]) <span class="built_in">eachTarjan</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重构图 将子树的性质嫁接到 SCC 的根上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : E[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[u] != fa[v]) Etmp[fa[u]].<span class="built_in">push_back</span>(fa[v]);</span><br><span class="line">        &#125;                              <span class="comment">// 存储新的边</span></span><br><span class="line">        wtmp[fa[u]] += w[u];           <span class="comment">// 存储新的边权</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">        w[u] = wtmp[u];</span><br><span class="line">        E[u] = Etmp[u];</span><br><span class="line">        <span class="built_in">sort</span>(E[u].<span class="built_in">begin</span>(), E[u].<span class="built_in">end</span>());</span><br><span class="line">        E[u].<span class="built_in">erase</span>(<span class="built_in">unique</span>(E[u].<span class="built_in">begin</span>(), E[u].<span class="built_in">end</span>()), E[u].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : E[u]) deg[v] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deg[u] &amp;&amp; u == fa[u]) Q.<span class="built_in">push</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> to : E[u]) &#123;</span><br><span class="line">            w[to] += w[u];</span><br><span class="line">            deg[to] -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!deg[to]) &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ---------------- 线段树 ----------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((cl+cr)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len (cr-cl+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls,cl,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs,mid+1,cr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树 树上的边先连上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p = <span class="number">1</span>, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cl == cr) <span class="keyword">return</span> w[p] = &#123; cl,cl &#125;, rt[cl] = p, <span class="built_in">void</span>();</span><br><span class="line">    E[ls].<span class="built_in">push_back</span>(p), <span class="built_in">build</span>(lson);</span><br><span class="line">    E[rs].<span class="built_in">push_back</span>(p), <span class="built_in">build</span>(rson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [l,r] 向 x 连边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> p = <span class="number">1</span>, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> E[p].<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">addedge</span>(l, r, x, lson);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; r)  <span class="built_in">addedge</span>(l, r, x, rson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ---------------- 主函数 ----------------</span></span><br><span class="line">ll xi[N], ri[N];  <span class="comment">// 1e18 范围需要 LL</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        xi[i] = <span class="built_in">read</span>(), ri[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">lower_bound</span>(xi + <span class="number">1</span>, xi + n + <span class="number">1</span>, xi[i] - ri[i]) - xi,      <span class="comment">// 二分找第一个大于等于 xi[i]-ri[i] 的 l 即是下界</span></span><br><span class="line">            r = <span class="built_in">upper_bound</span>(xi + <span class="number">1</span>, xi + n + <span class="number">1</span>, xi[i] + ri[i]) - xi - <span class="number">1</span>;  <span class="comment">// 二分找第一个大于 xi[i]+ri[i] 的 r 即是上界上面的那一个 再 -1 即是上界</span></span><br><span class="line">        <span class="built_in">addedge</span>(l, r, rt[i]);   <span class="comment">// Slime i will eat [l,r]</span></span><br><span class="line">        <span class="comment">// rt[] 数组表示 i 在新图上点的编号是 rt[i]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tarjan</span>(n &lt;&lt; <span class="number">2</span>), <span class="built_in">topo</span>(n &lt;&lt; <span class="number">2</span>);  <span class="comment">// 缩个点再跑一圈</span></span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        res += <span class="number">1ll</span> * i * (w[fa[rt[i]]].r - w[fa[rt[i]]].l + <span class="number">1</span>);</span><br><span class="line">        res %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苯人正在研究 <strong>史莱姆算法</strong>，有机会再补。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="http://kobicgend.top">小明同學</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結:</span> <span class="post-copyright-info"><a href="http://kobicgend.top/posts/e76188d.html">http://kobicgend.top/posts/e76188d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明:</span> <span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="http://kobicgend.top" target="_blank">小明の雜貨屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ACM/">ACM</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E7%AD%86%E8%A8%98/">筆記</a><a class="post-meta__tags" href="/tags/%E5%9C%96%E8%AB%96/">圖論</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/70031b2f.html" title="XCPC wiki - Short-Path Problem 最短路"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">XCPC wiki - Short-Path Problem 最短路</div></div><div class="info-2"><div class="info-item-1">单源最短路 正权图 朴素 Dijkstra $\Theta(n^2)$ 优化 Dijkstra $\Theta(m\log m)$ 负权图 Bellman - Ford $\Theta(nm)$ SPFA $\Theta(nm)$ 多源最短路 负权图 Johnson $\Theta(nm\log m)$ Floyd $\Theta(n^3)$ 正权图的单源最短路 Input Output 4 6 1 4 1 2 2 2 3 2 2 4 1 1 3 5 3 4 3 1 4 4 0 2 4 31 1 1 14&lt;-2&lt;-1 稠密图——朴素 Dijkstra 从未确定最短路的点中选取最短路长度最小的点，为未确定最短路的点松弛出边，即 $d_v=\min\left\lbrace d_v,\ d_u+w_{uv}\right\rbrace$，循环 $n$ 轮。 时间复杂度 $\Theta(n^2)$，空间 $\Theta(n^2)$，适用于点数较少、边数较多的稠密图。 12345678910111213141516auto...</div></div></div></a><a class="pagination-related" href="/posts/48cd0a2a.html" title="XCPC wiki - 网络流"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">XCPC wiki - 网络流</div></div><div class="info-2"><div class="info-item-1">在一个有向图上选择一个 源点 (s)，一个 汇点 (t)，每一条边上都有一个流量上限（以下称为 容量 ©），即经过这条边的流量不能超过这个上界，同时，除源点和汇点外，所有点的入流和出流都 相等，而源点只有流出的流，汇点只有汇入的流。 最大流（Max-flow） 使得流的值最大的流函数被称为网络的最大流 , 此时的 流的值被称为网络的最大流量。 Ford-Fulkerson Algorithm 一句话概括：添加反向边使流量可以回退。 共有 $m$ 条边，最大流量为 $f$ ，每一次循环至少会让最大流增大一份，故时间复杂度最坏情况下为 $O(f·m)$。 Edmonds-Karp Algorithm 为对 FF 的优化：在寻找简单路径时将图视为边权为 1 的无向图并对其跑最短路，即 BFS。（这里也可以理解为 EK 算法是 FF 算法的一种实现，因为 FF 算法并没有对路径选择有任何约束。） 共有 $n$ 个点，$m$ 条边时，残余图最多有 $m$ 条反向边总共 $2·m$ 条边，每一轮最短路需要 $O(m)$，最多循环 $(m·n)$ 轮（证明复杂）。故时间复杂度为...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/366bb2f2.html" title="【组合计数杂谈】三道 Bingo 游戏题（备份）"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-01</div><div class="info-item-2">【组合计数杂谈】三道 Bingo 游戏题（备份）</div></div><div class="info-2"><div class="info-item-1">本文涉及的知识点：组合数公式，古典概型，Min-Max 反演及推广，卷积优化思想，状态压缩思想与状态压缩 DP，快速数论变换 NTT，快速数论变换 NTT，快速沃尔什变换 FWT。 本系列教程「以题带讲」，以典型题目为载体，着重讲解知识点的适用条件和使用方法，而规避复杂的理论推导。 我不擅长数学，对 CF 和区域赛的数学题，从简单计算到数论组合都望而却步。「tag 是数学吗那不做了。」 可能是因为网上的教程大多是罗列定理，给出大段证明，最后放几个例题链接。我没有耐心和能力读完整篇文章。 2024 ICPC World Finals Astana B. Bingo for the Win! Bingo 游戏，$n$ 个人每人要抢 $k$ 个数，主持人按随机顺序依次报数，报到每个数 $[1,10^{9}]$ 的概率相同。已知如果有多名选手要抢某个数字，那么编号小的选手总是优先抢到。问每个人成为最后一名（其他人都抢完了但自己还没抢完）的概率。 ...</div></div></div></a><a class="pagination-related" href="/posts/43a1bd89.html" title="樹上問題 - 樹形 DP"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-08</div><div class="info-item-2">樹上問題 - 樹形 DP</div></div><div class="info-2"><div class="info-item-1">Tree 1234567891011121314151617181920212223242526272829303132333435363738struct node &#123; string data; int l, r;&#125;t[10005];void pretvs(int k) &#123; // 先序遍历：先遍历根节点，然后遍历左节点，最后遍历右节点 if (k == 0)return; cout &lt;&lt; t[k].data; if (t[k].l != 0) pretvs(t[k].l); if (t[k].r != 0) pretvs(t[k].r);&#125;void intvs(int k) &#123;// 中序遍历：先遍历左节点，然后遍历根节点，最后遍历右节点（大概可以理解为把树平面投影至二维从左到右） if (k == 0)return; if (t[k].l != 0) intvs(t[k].l); cout &lt;&lt; t[k].data; if (t[k].r !=...</div></div></div></a><a class="pagination-related" href="/posts/ba204004.html" title="Good Bye 2024: 2025 is NEAR A - E"><img class="cover" src="/img/posts/acm/codeforces-cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-11</div><div class="info-item-2">Good Bye 2024: 2025 is NEAR A - E</div></div><div class="info-2"><div class="info-item-1">无向图有边权。有 $q$ 个形式为 $(a, b, k)$ 的查询：从顶点 $a$ 到顶点 $b$ 的所有路径中，找出路径 上第 $k$ 大边权的最小值。$n \leqslant 400,\ q \leqslant 3 \times 10^{5}$。 枚举答案 $w$，把边权 $\leqslant w$ 的变成 0，$&gt; w$ 的变成 1。如果 $d_{a\to b}&lt;k$，就说明答案 $\leqslant w$。</div></div></div></a><a class="pagination-related" href="/posts/f9a46751.html" title="Codeforces Round 982 (Div. 2)"><img class="cover" src="/img/posts/acm/codeforces-cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-27</div><div class="info-item-2">Codeforces Round 982 (Div. 2)</div></div><div class="info-2"><div class="info-item-1">A. Rectangle Arrangement 取最大值的正确性：凸阶梯形平移后即是矩形，其周长与矩形周长相等。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; int X = 0, Y = 0; while (n--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; X = max(X, x); Y = max(Y, y); ...</div></div></div></a><a class="pagination-related" href="/posts/ec4161c0.html" title="Codeforces Round 1008 (Div. 1) A - C"><img class="cover" src="/img/posts/acm/codeforces-cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">Codeforces Round 1008 (Div. 1) A - C</div></div><div class="info-2"><div class="info-item-1">2077A/2078C - Breach of Faith 取较大的 $\cfrac{n}{2}+1$ 个放在奇数位，较小的放在偶数位。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() &#123; int J; cin &gt;&gt; J; while (J--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n * 2); for (int i = 0; i &lt; n * 2; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a.begin(), a.end()); vector&lt;ll&gt;...</div></div></div></a><a class="pagination-related" href="/posts/6370b5c4.html" title="Educational Codeforces Round 176 (Rated for Div. 2) A-D"><img class="cover" src="/img/posts/acm/codeforces-cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-28</div><div class="info-item-2">Educational Codeforces Round 176 (Rated for Div. 2) A-D</div></div><div class="info-2"><div class="info-item-1">edu 场神秘分类讨论，神秘推式子。 2075A - To Zero 一次偶数那之后都是偶数。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int J; cin &gt;&gt; J; while (J--) &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; int res = 0; if (n &amp; 1) &#123; n = max(0, n - k); res++; &#125; k--; res += (n + k - 1) / k; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; 2075B - Array...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>評論</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">小明同學</div><div class="author-info-description">「一直游到海水變藍。」</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">381</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kobicgend"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">用於備份小明的腦子。<br>———— <b>Tips</b> ————<br>部分評論從QQ空間或puq抓取，由於技術有限，無法顯示正確的位置和時間，望見諒。<br>———— <b>本站常規欄目</b> ————<br>周日中午:高中回憶《中外历史纲要》<br>周二清晨:語錄體《主机註記》<br>周三下午:有事大家谈/掷地有声<br>周三/六晚上:算法學習筆記<br>———— <b>計劃中</b> ————<br>美食評測, 每日一圖, ...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stop-the-Castle"><span class="toc-text">Stop the Castle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF1634E-Fair-Share"><span class="toc-text">CF1634E. Fair Share</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%AC%94%E7%94%BB"><span class="toc-text">一笔画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CF1981D-Turtle-and-Multiplication"><span class="toc-text">CF1981D. Turtle and Multiplication</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VJspr1G-Chemical-table"><span class="toc-text">VJspr1G - Chemical table</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E7%8E%AF"><span class="toc-text">置换环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9D%8C%E8%9A%AA%E5%9B%BE"><span class="toc-text">蝌蚪图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CF1787D-Game-on-Axis"><span class="toc-text">CF1787D. Game on Axis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-ICPC-%20%E6%9D%AD%E5%B7%9E%20-H-Sugar-Sweet-II"><span class="toc-text">2023 ICPC 杭州 H. Sugar Sweet II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="toc-text">差分约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A2%98"><span class="toc-text">杂题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CF1815C-Between"><span class="toc-text">CF1815C. Between</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VJsum1K-Slime"><span class="toc-text">VJsum1K. Slime</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/31f676fd.html" title="〔主机註記〕第 105 周主机註記 (Feb.9 - Feb.15)"><img src="/img/zhuji-cover.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="〔主机註記〕第 105 周主机註記 (Feb.9 - Feb.15)"></a><div class="content"><a class="title" href="/posts/31f676fd.html" title="〔主机註記〕第 105 周主机註記 (Feb.9 - Feb.15)">〔主机註記〕第 105 周主机註記 (Feb.9 - Feb.15)</a><time datetime="2026-02-09T22:30:00.000Z" title="更新於 2026-02-10 06:30:00">2026-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9c43eea3.html" title="〔主机註記〕第 104 周主机註記 (Feb.2 - Feb.8)"><img src="/img/zhuji-cover.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="〔主机註記〕第 104 周主机註記 (Feb.2 - Feb.8)"></a><div class="content"><a class="title" href="/posts/9c43eea3.html" title="〔主机註記〕第 104 周主机註記 (Feb.2 - Feb.8)">〔主机註記〕第 104 周主机註記 (Feb.2 - Feb.8)</a><time datetime="2026-02-02T22:30:00.000Z" title="更新於 2026-02-03 06:30:00">2026-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/449a65b8.html" title="〔主机註記〕第 103 周主机註記 (Janu.26 - Feb.1)"><img src="/img/zhuji-cover.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="〔主机註記〕第 103 周主机註記 (Janu.26 - Feb.1)"></a><div class="content"><a class="title" href="/posts/449a65b8.html" title="〔主机註記〕第 103 周主机註記 (Janu.26 - Feb.1)">〔主机註記〕第 103 周主机註記 (Janu.26 - Feb.1)</a><time datetime="2026-01-26T22:30:00.000Z" title="更新於 2026-01-27 06:30:00">2026-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7cd85ddd.html" title="〔主机註記〕第 102 周主机註記 (Janu.19 - Janu.25)"><img src="/img/zhuji-cover.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="〔主机註記〕第 102 周主机註記 (Janu.19 - Janu.25)"></a><div class="content"><a class="title" href="/posts/7cd85ddd.html" title="〔主机註記〕第 102 周主机註記 (Janu.19 - Janu.25)">〔主机註記〕第 102 周主机註記 (Janu.19 - Janu.25)</a><time datetime="2026-01-19T22:30:00.000Z" title="更新於 2026-01-20 06:30:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e0c306a7.html" title="〔主机註記〕第 101 周主机註記 (Janu.12 - Janu.18)"><img src="/img/zhuji-cover.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="〔主机註記〕第 101 周主机註記 (Janu.12 - Janu.18)"></a><div class="content"><a class="title" href="/posts/e0c306a7.html" title="〔主机註記〕第 101 周主机註記 (Janu.12 - Janu.18)">〔主机註記〕第 101 周主机註記 (Janu.12 - Janu.18)</a><time datetime="2026-01-12T22:30:00.000Z" title="更新於 2026-01-13 06:30:00">2026-01-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2026 By 小明同學</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"none"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const n=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],n),d=document.createTextNode("");e.parentNode.replaceChild(d,e),a.start={node:d,delim:"",n:0},a.end={node:d,delim:"",n:0},t.math.push(a)}},""]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{const o="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,t=null,e=(e=document,n=location.pathname)=>{twikoo.init({el:e.querySelector("#twikoo-wrap"),envId:"https://twikoo.kobicgend.top/",region:"ap-shanghai",onCommentLoaded:()=>{btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))},...t,path:n}),o&&(window.shuoshuoComment.destroyTwikoo=()=>{e.children.length&&(e.innerHTML="",e.classList.add("no-comment"))})},n=(o,t)=>{"object"==typeof twikoo?setTimeout(()=>e(o,t),0):btf.getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>e(o,t))};o?window.shuoshuoComment={loadComment:n}:n()})()</script></div><script src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script></body></html>