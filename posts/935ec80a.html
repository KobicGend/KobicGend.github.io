<!DOCTYPE html><html lang="zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>XCPC wiki - 区间信息 | 小明の雜貨屋</title><meta name="author" content="小明同學"><meta name="copyright" content="小明同學"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ST Table ST 表 (Sparse Table, 稀疏表) 基于 倍增  思想，用于解决  可重复贡献问题 $^\dagger$，支持在 $\Theta(1)$ 的时间内 区间查询，不支持在线修改。 递推计算所有长度为 $2$ 的幂的区间的结果。对于询问 $[\mathscr{l}, r)$，记 $k &#x3D; \lfloor \log_2(r - \mathscr{l}) \rfloor$，结"><meta property="og:type" content="article"><meta property="og:title" content="XCPC wiki - 区间信息"><meta property="og:url" content="http://kobicgend.top/posts/935ec80a.html"><meta property="og:site_name" content="小明の雜貨屋"><meta property="og:description" content="ST Table ST 表 (Sparse Table, 稀疏表) 基于 倍增  思想，用于解决  可重复贡献问题 $^\dagger$，支持在 $\Theta(1)$ 的时间内 区间查询，不支持在线修改。 递推计算所有长度为 $2$ 的幂的区间的结果。对于询问 $[\mathscr{l}, r)$，记 $k &#x3D; \lfloor \log_2(r - \mathscr{l}) \rfloor$，结"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="http://kobicgend.top/img/avatar.webp"><meta property="article:published_time" content="2025-01-24T14:05:00.000Z"><meta property="article:modified_time" content="2025-01-24T14:05:00.000Z"><meta property="article:author" content="小明同學"><meta property="article:tag" content="ACM"><meta property="article:tag" content="筆記"><meta property="article:tag" content="數據結構"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://kobicgend.top/img/avatar.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "XCPC wiki - 区间信息",
  "url": "http://kobicgend.top/posts/935ec80a.html",
  "image": "http://kobicgend.top/img/avatar.webp",
  "datePublished": "2025-01-24T14:05:00.000Z",
  "dateModified": "2025-01-24T14:05:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "小明同學",
      "url": "http://kobicgend.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.webp"><link rel="canonical" href="http://kobicgend.top/posts/935ec80a.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const n=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:n}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:n}=JSON.parse(t);if(!(Date.now()>n))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,n)=>{const a=document.createElement("script");a.src=e,a.async=!0,Object.entries(t).forEach(([e,t])=>a.setAttribute(e,t)),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||o()},a.onerror=n,document.head.appendChild(a)}),getCSS:(e,t)=>new Promise((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||o()},a.onerror=n,document.head.appendChild(a)}),addGlobalFn:(e,t,o=!1,n=window)=>{if(e.startsWith("pjax"))return;const a=n.globalFn||{};a[e]=a[e]||{},a[e][o||Object.keys(a[e]).length]=t,n.globalFn=a}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","undefined")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","undefined")};btf.activateDarkMode=t,btf.activateLightMode=o;const n=e.get("theme");"dark"===n?t():"light"===n&&o();const a=e.get("aside-status");void 0!==a&&document.documentElement.classList.toggle("hide-aside","hide"===a);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"複製成功",error:"複製失敗",noSupport:"瀏覽器不支援"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"剛剛",min:"分鐘前",hour:"小時前",day:"天前",month:"個月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"載入更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!0,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"XCPC wiki - 区间信息",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/fonts.css"><link rel="stylesheet" href="/css/title.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/masktag.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">載入中...</div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o=()=>{e.style.overflow="",d.classList.add("loaded")},l=()=>{e.style.overflow="hidden",d.classList.remove("loaded")};l(),window.addEventListener("load",o)})()</script><div id="web_bg" style="background-image:url(/img/background.webp)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">382</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">23</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-book"></i> <span>記事簿</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/diary/diary-stz/"><i class="fa-fw fa fa-book"></i> <span>《中外历史纲要》</span></a></li><li><a class="site-page child" href="/categories/%E6%97%A5%E8%A8%98/%E4%B8%BB%E6%9C%BA%E8%A8%BB%E8%A8%98/"><i class="fa-fw fa fa-book"></i> <span>《主机註記》</span></a></li><li><a class="site-page child" href="/diary/hutaolinriji/"><i class="fa-fw fa fa-book"></i> <span>楜桃林日記</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-open"></i> <span>筆記本</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/935ec80a.html"><i class="fa-fw fa fa-quran"></i> <span>XCPC</span></a></li><li><a class="site-page child" href="/notes/"><i class="fa-fw fa fa-tanakh"></i> <span>大學筆記</span></a></li><li><a class="site-page child" href="/notes/"><i class="fa-fw fa fa-tanakh"></i> <span>其它筆記</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-palette"></i> <span>作品集</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E4%BD%9C%E5%93%81/%E5%BE%AE%E4%BF%A1%E5%85%AC%E7%9C%BE%E8%99%9F/"><i class="fa-fw fa fa-radio"></i> <span>CUC-Radio</span></a></li><li><a class="site-page child" href="/posts/e7eea71f.html"><i class="fa-fw fa fa-stamp"></i> <span>篆刻作品展</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-toolbox"></i> <span>工具箱</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Music/"><i class="fa-fw fa fa-music"></i> <span>Music</span></a></li><li><a class="site-page child" href="/categories/Poetry/"><i class="fa-fw fa fa-guitar"></i> <span>詩詞</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i> <span>更多</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/c096c313.html"><i class="fa-fw fa fa-subway"></i> <span>地鐵圖</span></a></li><li><a class="site-page child" href="/ovo/eikon"><span>賽博空調</span></a></li><li><a class="site-page child" href="/ovo/tabe"><span>中午吃什么</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>好盆友</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-user"></i> <span>關於小明</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/index.webp)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">小明の雜貨屋</span></a><a class="nav-page-title" href="/"><span class="site-name">XCPC wiki - 区间信息</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-book"></i> <span>記事簿</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/diary/diary-stz/"><i class="fa-fw fa fa-book"></i> <span>《中外历史纲要》</span></a></li><li><a class="site-page child" href="/categories/%E6%97%A5%E8%A8%98/%E4%B8%BB%E6%9C%BA%E8%A8%BB%E8%A8%98/"><i class="fa-fw fa fa-book"></i> <span>《主机註記》</span></a></li><li><a class="site-page child" href="/diary/hutaolinriji/"><i class="fa-fw fa fa-book"></i> <span>楜桃林日記</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-open"></i> <span>筆記本</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/935ec80a.html"><i class="fa-fw fa fa-quran"></i> <span>XCPC</span></a></li><li><a class="site-page child" href="/notes/"><i class="fa-fw fa fa-tanakh"></i> <span>大學筆記</span></a></li><li><a class="site-page child" href="/notes/"><i class="fa-fw fa fa-tanakh"></i> <span>其它筆記</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-palette"></i> <span>作品集</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E4%BD%9C%E5%93%81/%E5%BE%AE%E4%BF%A1%E5%85%AC%E7%9C%BE%E8%99%9F/"><i class="fa-fw fa fa-radio"></i> <span>CUC-Radio</span></a></li><li><a class="site-page child" href="/posts/e7eea71f.html"><i class="fa-fw fa fa-stamp"></i> <span>篆刻作品展</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-toolbox"></i> <span>工具箱</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Music/"><i class="fa-fw fa fa-music"></i> <span>Music</span></a></li><li><a class="site-page child" href="/categories/Poetry/"><i class="fa-fw fa fa-guitar"></i> <span>詩詞</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i> <span>更多</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/c096c313.html"><i class="fa-fw fa fa-subway"></i> <span>地鐵圖</span></a></li><li><a class="site-page child" href="/ovo/eikon"><span>賽博空調</span></a></li><li><a class="site-page child" href="/ovo/tabe"><span>中午吃什么</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>好盆友</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-user"></i> <span>關於小明</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">XCPC wiki - 区间信息</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2025-01-24T14:05:00.000Z" title="發表於 2025-01-24 22:05:00">2025-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-01-24T14:05:00.000Z" title="更新於 2025-01-24 22:05:00">2025-01-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AD%86%E8%A8%98/">筆記</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AD%86%E8%A8%98/XCPCwiki/">XCPCwiki</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">總字數:</span><span class="word-count">19.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀時間:</span><span>95分鐘</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>ST Table</h1><p><strong>ST 表 (Sparse Table, 稀疏表)</strong> 基于 <strong>倍增</strong> 思想，用于解决 <strong>可重复贡献问题 $^\dagger$</strong>，支持在 $\Theta(1)$ 的时间内 <strong>区间查询</strong>，不支持在线修改。</p><p>递推计算所有长度为 $2$ 的幂的区间的结果。对于询问 $[\mathscr{l}, r)$，记 $k = \lfloor \log_2(r - \mathscr{l}) \rfloor$，结果为 $[\mathscr{l}, \mathscr{l} + 2^k)$ 和 $[r - 2^k, r)$ 的结果的并。</p><blockquote><p>$^\dagger:$ 区间询问对应的运算符 $<em>$ 满足 $x</em>x=x$ 和结合律 $(x<em>y)<em>z=x</em>(y</em>z)$ ，如 $\max,\ \min,\ |\ ,\ &amp;,\ \gcd$ 等，包括 RMQ (Range Maximum/Minimum Query) 问题和区间 GCD。</p></blockquote><p>标准 RMQ，复杂度 $\Theta(n \log \log n) - \Theta(1)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Cmp</span> = less&lt;T&gt;&gt;  <span class="comment">// greater: 最大值 less: 最小值</span></span><br><span class="line"><span class="keyword">struct</span> RMQ &#123;</span><br><span class="line">    <span class="type">const</span> Cmp cmp = <span class="built_in">Cmp</span>();</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> B = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;T&gt;&gt; a;</span><br><span class="line">    vector&lt;T&gt; pre, suf, ini;</span><br><span class="line">    vector&lt;u64&gt; stk;</span><br><span class="line">    <span class="built_in">RMQ</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">RMQ</span>(<span class="type">const</span> vector&lt;T&gt;&amp; v) &#123;</span><br><span class="line">        <span class="built_in">init</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> vector&lt;T&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        n = v.<span class="built_in">size</span>();</span><br><span class="line">        pre = suf = ini = v;</span><br><span class="line">        stk.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> M = (n - <span class="number">1</span>) / B + <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> lg = __lg(M);</span><br><span class="line">        a.<span class="built_in">assign</span>(lg + <span class="number">1</span>, <span class="built_in">vector</span>&lt;T&gt;(M));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            a[<span class="number">0</span>][i] = v[i * B];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; B &amp;&amp; i * B + j &lt; n; j++) &#123;</span><br><span class="line">                a[<span class="number">0</span>][i] = <span class="built_in">min</span>(a[<span class="number">0</span>][i], v[i * B + j], cmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % B) &#123;</span><br><span class="line">                pre[i] = <span class="built_in">min</span>(pre[i], pre[i - <span class="number">1</span>], cmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % B != B - <span class="number">1</span>) &#123;</span><br><span class="line">                suf[i] = <span class="built_in">min</span>(suf[i], suf[i + <span class="number">1</span>], cmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; lg; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + (<span class="number">2</span> &lt;&lt; j) &lt;= M; i++) &#123;</span><br><span class="line">                a[j + <span class="number">1</span>][i] = <span class="built_in">min</span>(a[j][i], a[j][i + (<span class="number">1</span> &lt;&lt; j)], cmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> l = i * B;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r = <span class="built_in">min</span>(<span class="number">1U</span> * n, l + B);</span><br><span class="line">            u64 s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; r; j++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (s &amp;&amp; <span class="built_in">cmp</span>(v[j], v[__lg(s) + l])) &#123;</span><br><span class="line">                    s ^= <span class="number">1ULL</span> &lt;&lt; __lg(s);</span><br><span class="line">                &#125;</span><br><span class="line">                s |= <span class="number">1ULL</span> &lt;&lt; (j - l);</span><br><span class="line">                stk[j] = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;  <span class="comment">// [l, r)</span></span><br><span class="line">        <span class="keyword">if</span> (l / B != (r - <span class="number">1</span>) / B) &#123;</span><br><span class="line">            T ans = <span class="built_in">min</span>(suf[l], pre[r - <span class="number">1</span>], cmp);</span><br><span class="line">            l = l / B + <span class="number">1</span>;</span><br><span class="line">            r = r / B;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> k = __lg(r - l);</span><br><span class="line">                ans = <span class="built_in">min</span>(&#123; ans, a[k][l], a[k][r - (<span class="number">1</span> &lt;&lt; k)] &#125;, cmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> x = B * (l / B);</span><br><span class="line">            <span class="keyword">return</span> ini[__builtin_ctzll(stk[r - <span class="number">1</span>] &gt;&gt; (l - x)) + l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>精简 RMQ，复杂度为 $\Theta(n \log n) - \Theta(1)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Cmp</span> = greater&lt;T&gt;&gt;  <span class="comment">// greater: 最大值 less: 最小值</span></span><br><span class="line"><span class="keyword">struct</span> RMQ &#123;  <span class="comment">// 存的是值</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> D = <span class="number">30</span>;</span><br><span class="line">    <span class="type">const</span> Cmp cmp = <span class="built_in">Cmp</span>();</span><br><span class="line">    vector&lt;T&gt; t[D + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RMQ</span><span class="params">(vector&lt;T&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        t[<span class="number">0</span>] = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= __lg(n); d++) &#123;</span><br><span class="line">            t[d].<span class="built_in">resize</span>(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + (<span class="number">1ll</span> &lt;&lt; d) &lt;= n; ++i) &#123;</span><br><span class="line">                t[d][i] = <span class="built_in">min</span>(t[d - <span class="number">1</span>][i], t[d - <span class="number">1</span>][i + (<span class="number">1ll</span> &lt;&lt; (d - <span class="number">1</span>))], cmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;  <span class="comment">// [l, r)</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> d = __lg(r - l);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(t[d][l], t[d][r - (<span class="number">1ll</span> &lt;&lt; d)], cmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Cmp</span> = less&lt;T&gt;&gt;  <span class="comment">// greater: 最大值 less: 最小值</span></span><br><span class="line"><span class="keyword">struct</span> RMQ &#123;  <span class="comment">// 存的是下标</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> D = <span class="number">30</span>;</span><br><span class="line">    <span class="type">const</span> Cmp cmp = <span class="built_in">Cmp</span>();</span><br><span class="line">    vector&lt;T&gt; a, t[D + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RMQ</span><span class="params">(vector&lt;T&gt;&amp; a)</span> : a(a) &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        t[<span class="number">0</span>].<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="built_in">iota</span>(t[<span class="number">0</span>].<span class="built_in">begin</span>(), t[<span class="number">0</span>].<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= __lg(n); d++) &#123;</span><br><span class="line">            t[d].<span class="built_in">resize</span>(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + (<span class="number">1ll</span> &lt;&lt; d) &lt;= n; i++) &#123;</span><br><span class="line">                <span class="type">int</span>&amp; ls = t[d - <span class="number">1</span>][i], &amp; rs = t[d - <span class="number">1</span>][i + (<span class="number">1ll</span> &lt;&lt; (d - <span class="number">1</span>))];</span><br><span class="line">                t[d][i] = <span class="built_in">min</span>(a[ls], a[rs], cmp) == a[rs] ? rs : ls;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;  <span class="comment">// [l, r)</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> d = __lg(r - l);</span><br><span class="line">        <span class="type">int</span>&amp; p = t[d][l], &amp; q = t[d][r - (<span class="number">1ll</span> &lt;&lt; d)];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(a[p], a[q], cmp) == a[q] ? q : p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>RMQ 问题的其它解决方法：</p><p><strong>离线 + 单调栈</strong> 考虑栈顶为 $i$ 单调栈和 $r = i + 1$ 的所有询问。在单调栈上二分查找最小的 $\geqslant l$ 的下标。复杂度为 $\Theta(n + q \log n)$。</p><p><strong>分块</strong> 块大小为 $B$。对于块的结果形成的序列，计算所有区间的最小值，这部分复杂度为 $\Theta((\frac{n}{B})^2)$。对每个块计算块内前缀最小值和后缀最小值，这部分复杂度为 $\Theta(n)$。若询问至少和两个块有交, 复杂度为 $\Theta(1)$；否则为 $\Theta(B)$。这部分复杂度为 $\Theta(qB)$。取 $B = n^{2/3} q^{-1/3}$，复杂度为 $\Theta(n^{8/3})$。</p><p><strong>线性算法</strong> 块大小为 $w$, 在 Word-RAM 模型中 $w = \Omega(\log n)$, $w$ 位整数位运算复杂度为 $\Theta(1)$。对于块的结果形成的序列, 使用稀疏表, 由于 $n \leqslant w \log n$ 这 部分复杂度为 $\Theta(n)$。对每个块计算块内前缀最小值和后缀最小值, 这部分复杂度为 $\Theta(n)$。对每个块在块内计算每个单调栈的二进制表示, 通过位运算可以使得计算单调栈均摊复杂度和询问复杂的都是 $\Theta(1)$。复杂度为 $\Theta(n) - \Theta(1)$。</p><div style="page-break-after:always"></div><h1>BIT 树状数组</h1><p><strong>树状数组 (bisrch Index Tree, 二进制下标树)</strong> 用于维护满足 <strong>结合律</strong> 和 <strong>可差分</strong> （即具有逆运算，如和、积、异或）的区间信息，支持在 $\Theta(n)$ 的空间和 $\Theta(\log n)$ 的时间内  <strong>单点修改</strong>  和  <strong>区间查询</strong>。</p><p>树上节点 $p$ 存储区间 $(p-\operatorname{lowbit}p,\ p]$ 的某个性质，其中 $\operatorname{lowbit}p$ 表示 $p$ 的二进制中 1 的最低位。前缀查询 $[1,p]$ 可按二进制拆成对 $\Theta(\log p)$ 个子区间求和。</p><p>以维护区间的和（单点修改和区间查询）为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="built_in">BIT</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        N = n + <span class="number">1</span>;</span><br><span class="line">        t.<span class="built_in">resize</span>(N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; N) t[p] += x, p += p &amp; -p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) res += t[p], p -= p &amp; -p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>例题 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3374">洛谷 P3374</a></p></blockquote><div style="page-break-after:always"></div><h2 id="BIT-1- 权值树状数组 -×- 二维偏序">BIT.1 权值树状数组 × 二维偏序</h2><p>在二维的情形，分别对两个属性定义序关系，一定能得到一种偏序关系：<br>$$<br>(a_j,b_j)\prec(a_i,b_i) ;\xlongequal{def}; a_j\lesseqgtr a_i;\text{and}; b_j\lesseqgtr b_i<br>$$</p><p>二维偏序问题一般用 <strong>树状数组</strong> 解决。</p><h3 id="模板">模板</h3><p>给定平面直角坐标系上的若干点，定义点的等级为既不在它上面也不在它右边的点的数量，求每个等级的点的数量。数据范围：$n \leqslant 5\times10^{5},\ 0 &lt; x,y &lt; n$。</p><p>分析：这定义了偏序关系<br>$$<br>(a_j,b_j)\prec(a_i,b_i) ;\xlongequal{def}; a_j\ \leqslant a_i;\text{and}; b_j \leqslant b_i<br>$$</p><p>选 $a$ 为第一关键词，$b$ 为第二关键词排序，按顺序将 $b$ 存入树状数组，动态求前缀和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    ll t[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x)</span> </span>&#123; <span class="keyword">while</span> (p &lt; N) t[p] += x, p += p &amp; -p; &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; ll res = <span class="number">0</span>; <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) res += t[p], p -= p &amp; -p; <span class="keyword">return</span> res; &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>); &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">a</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y] : a) x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    bit.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y] : a) &#123;</span><br><span class="line">        ans[bit.<span class="built_in">query</span>(y)] += <span class="number">1</span>;</span><br><span class="line">        bit.<span class="built_in">modify</span>(y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用：逆序对">应用：逆序对</h3><p>逆序对的本质：<br>$$<br>(j,a_j)\prec(i,a_i) ;\xlongequal{def}; j\lt i;\text{and}; a_j\gt a_i<br>$$</p><p>将序列从后向前倒着插入 BIT，插入 $a_i$ 前，统计已插入的比 $a_i$ 小的数字的数量 <code>query(a[i])</code>，即是序列中满足 $j&gt;i,\ a_j&lt;a_i$ 的数量，也即 $a_i$ 对应的逆序对的数量。考虑到给出的数字较大，且存在负数，又注意到逆序数只与数字的相对大小有关，先 <strong>离散化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    ll t[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x)</span> </span>&#123; <span class="keyword">while</span> (p &lt; N) t[p] += x, p += p &amp; -p; &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; ll res = <span class="number">0</span>; <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) res += t[p], p -= p &amp; -p; <span class="keyword">return</span> res; &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>); &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) b[i] = &#123; <span class="built_in">read</span>(),i &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[b[i].second] = i;  <span class="comment">// 离散化</span></span><br><span class="line"></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    bit.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        sum += bit.<span class="built_in">query</span>(a[i]);    <span class="comment">// 插入前统计</span></span><br><span class="line">        bit.<span class="built_in">modify</span>(a[i], <span class="number">1</span>);       <span class="comment">// 倒着插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong> 更标准的离散化写法，即复制、排序、去重、查找，时间复杂度 $\Theta(n\log n)$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[N], val[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(val, arr, <span class="keyword">sizeof</span> arr);                       <span class="comment">// 复制</span></span><br><span class="line">    <span class="built_in">sort</span>(val, val + n);                            <span class="comment">// 排序</span></span><br><span class="line">    <span class="type">int</span> val_size = <span class="built_in">unique</span>(val, val + n) - val;   <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)                         <span class="comment">// 查找</span></span><br><span class="line">        arr[i] = <span class="built_in">lower_bound</span>(val, val + val_size, arr[i]) - val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例题 <a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1394">HDU1394 Minimum Inversion Number</a></p></blockquote><h3 id="更一般的情形">更一般的情形</h3><p>而其他二维偏序关系，可以作不同的处理转化为最简单的二维偏序。例如：</p><ul><li>$(a_j,b_j)\prec(a_i,b_i) ;\xlongequal{def}; a_j\lt a_i;\text{and}; ?$：把第一关键词的小于等于改成小于，需要在对第二关键词排序时进行 <strong>逆序排序</strong>。</li><li>$(a_j,b_j)\prec(a_i,b_i) ;\xlongequal{def}; a_j \geqslant a_i;\text{and}; ?$：把第一关键词的小于等于改成大于等于，需要在对第一关键词排序时进行 <strong>逆序排序</strong>。</li><li>$(a_j,b_j)\prec(a_i,b_i) ;\xlongequal{def}; a_j\gt a_i;\text{and}; ?$：把第一关键词的小于等于改成大于，需要在对两个关键词排序时都进行 <strong>逆序排序</strong>。</li><li>$(a_j,b_j)\prec(a_i,b_i) ;\xlongequal{def}; ?;\text{and}; b_j\lt b_i$：把第二关键词的小于等于改成小于，查询时使用 <code>query(x-1)</code> 而不是 <code>query(x)</code>。</li><li>$(a_j,b_j)\prec(a_i,b_i) ;\xlongequal{def}; ?;\text{and}; b_j \geqslant b_i$：把第二关键词的小于等于改成大于等于，对第二关键词 <strong>离散化</strong> 时进行 <strong>逆序排序</strong>。</li><li>$(a_j,b_j)\prec(a_i,b_i) ;\xlongequal{def}; ?;\text{and}; b_j \geqslant b_i$：把第二关键词的小于等于改成大于等于，对第二关键词 <strong>离散化</strong> 时进行 <strong>逆序排序</strong>，并且查询时使用 <code>query(x-1)</code> 而不是 <code>query(x)</code>。</li></ul><h3 id="例题">例题</h3><p>坐标轴 OX 上有 $n$ 个点。第 $i$ 个点的初始坐标为 $x_{i0}$（保证互不相同），速度为恒定值 $v_i$，则它在 $t\in\mathbb{R}<em>{+}$ 时刻的坐标为 $x</em>{i}(t)=x_{i0} + t v_i$。</p><p>设 $d(i, j)$ 为两点 $i$ 和 $j$ 之间的最小距离，即 $\min\limits_{t&gt;0}\lbrace |x_{i}(t)-x_{j}(t)| \rbrace$。</p><p>计算 $\sum\limits_{1 \leqslant i, j \leqslant n}$ $d(i, j)$。</p><p>| K | ⭐⭐ | 图论、线段树综合应用、思维 | <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5025">洛谷 P5025[SNOI2017]</a> |</p><div style="page-break-after:always"></div><h2 id="BIT-2- 高阶前缀和">BIT.2 高阶前缀和</h2><h4 id="BIT-2-1- 区间修改和单点查询">BIT.2.1 区间修改和单点查询</h4><p>利用差分，将此问题转化为单点修改和区间查询。具体地，记 $b_i = a_i - a_{i-1}$，则 $a_i = \sum b_j$，用 BIT 维护序列 $\lbrace b_i\rbrace$ 的前缀和，修改 $[l,r]$ 即 $b_l:=b_l+x,\ b_{r+1}:=b_{r+1}-x$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        bit.<span class="built_in">modify</span>(i, a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q = <span class="built_in">read</span>(); q--;) &#123;</span><br><span class="line">        <span class="type">int</span> op = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (op) bit.<span class="built_in">modify</span>(l, num), bit.<span class="built_in">modify</span>(r + <span class="number">1</span>, -num);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">print</span>(bit.<span class="built_in">query</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例题 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3368">洛谷 P3368</a></p></blockquote><div style="page-break-after:always"></div><h4 id="BIT-2-2- 区间修改和区间查询">BIT.2.2 区间修改和区间查询</h4><p>即线段树模板题。</p><p>类似地，利用差分，<br>$$s_k<br>= \sum_{i=1}^{k} a_i<br>= \sum_{i=1}^{k} \sum_{j=1}^{i} b_j<br>= \sum_{i=1}^{k} \sum_{j=i}^{k} b_i<br>= (k+1) \sum_{i=1}^{k} b_i - \sum\limits_{i=1}^{k} ib_i<br>$$<br>用两个 BIT 分别维护序列 $\lbrace b_i\rbrace$、$\lbrace ib_i\rbrace$ 的前缀和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll tr[N], tree2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> _n)</span> </span>&#123; <span class="keyword">return</span> _n &amp; (-_n); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = i; p &lt; N; p += <span class="built_in">lowbit</span>(p)) &#123;</span><br><span class="line">        tr[p] += num, tree2[p] += num * i;</span><br><span class="line">    &#125;   <span class="comment">// 维护什么写什么</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = i; p; p -= <span class="built_in">lowbit</span>(p)) &#123;</span><br><span class="line">        res += (i + <span class="number">1</span>) * tr[p] - tree2[p];</span><br><span class="line">    &#125;   <span class="comment">// 计算公式是什么就写什么</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="keyword">sizeof</span> tree);</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">modify</span>(i, a[i] - a[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q = <span class="built_in">read</span>(); q--;) &#123;</span><br><span class="line">        <span class="type">int</span> op = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (op) <span class="built_in">modify</span>(l, num), <span class="built_in">modify</span>(r + <span class="number">1</span>, -num);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">print</span>(<span class="built_in">query</span>(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例题 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3372">洛谷 P3372</a></p></blockquote><h4 id="BIT2-3- 高阶前缀和">BIT2.3 高阶前缀和</h4><p>一般地，对于 $m$ 阶前缀和，计算 $C_{k-x+m-1}^{m-1}$，得到关于 $x$ 的多项式 $a_0x^0 + a_1x^1 + a_2x^2 + \cdots$，则<br>$$s_k = a_0\sum\limits_{i=1}^{k} b_i + a_1 \sum\limits_{i=1}^{k} ib_i + a_2 \sum\limits_{i=1}^{k} i^2b_i + \cdots<br>$$</p><p>例如，当 $m=3$ 时，$s_k = \left(k^2+3k+2\right)\sum\limits_{i=1}^{k} b_i + \left(-2k-3\right) \sum\limits_{i=1}^{k} ib_i + \sum\limits_{i=1}^{k} i^2b_i$。</p><h2 id="BIT-2- 多维 -BIT">BIT.2 多维 BIT</h2><p>二维数组的区间修改和区间查询：构造差分数组 $b_{ij}$，则<br>$$<br>\begin{aligned}<br>s_{uv}<br>= \sum\limits_{i=1}^{u}\sum\limits_{j=1}^{v} a_{ij}<br>&amp;= \sum\limits_{i=1}^{u}\sum\limits_{j=1}^{v} \sum\limits_{k=1}^{i}\sum\limits_{l=1}^{j} b_{kl} \<br>&amp;= \sum\limits_{i=1}^{u}\sum\limits_{j=1}^{v} \sum\limits_{k=i}^{u}\sum\limits_{l=j}^{v} b_{ij} \<br>&amp;= \sum\limits_{i=1}^{u}\sum\limits_{j=1}^{v}<br>(u-i+1)(v-j+1)b_{ij} \<br>&amp;= (u+1)(v+1)\sum\limits_{i=1}^{u}\sum\limits_{j=1}^{v}b_{ij}<br>-u\sum\limits_{i=1}^{u}\sum\limits_{j=1}^{v}jb_{ij} \<br>&amp;\qquad\ -v\sum\limits_{i=1}^{u}\sum\limits_{j=1}^{v}ib_{ij}<br>+\sum\limits_{i=1}^{u}\sum\limits_{j=1}^{v}ijb_{ij}<br>\end{aligned}<br>$$</p><p>用四个 BIT 分别维护序列 $\lbrace b_{ij}\rbrace$、$\lbrace ib_{ij}\rbrace$、$\lbrace jb_{ij}\rbrace$、$\lbrace ijb_{ij}\rbrace$ 的前缀和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ll t1[N][N], t2[N][N], t3[N][N], t4[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> _n)</span> </span>&#123; <span class="keyword">return</span> _n &amp; (-_n); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = i; p &lt; N; p += <span class="built_in">lowbit</span>(p)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q = j; q &lt; N; q += <span class="built_in">lowbit</span>(q)) &#123;</span><br><span class="line">            t1[p][q] += num;</span><br><span class="line">            t2[p][q] += j * num;</span><br><span class="line">            t3[p][q] += i * num;</span><br><span class="line">            t4[p][q] += i * j * num;</span><br><span class="line">        &#125;   <span class="comment">// 维护什么写什么</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = i; p; p -= <span class="built_in">lowbit</span>(p)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q = j; q; q -= <span class="built_in">lowbit</span>(q)) &#123;</span><br><span class="line">            res += (i + <span class="number">1</span>) * (j + <span class="number">1</span>) * t1[p][q]</span><br><span class="line">                - (i + <span class="number">1</span>) * t2[p][q]</span><br><span class="line">                - (j + <span class="number">1</span>) * t3[p][q]</span><br><span class="line">                + t4[p][q];</span><br><span class="line">        &#125;   <span class="comment">// 计算公式是什么就写什么</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q = <span class="built_in">read</span>(); q--;) &#123;</span><br><span class="line">        <span class="type">int</span> op = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            <span class="type">int</span> x1 = <span class="built_in">read</span>(), y1 = <span class="built_in">read</span>(), x2 = <span class="built_in">read</span>(), y2 = <span class="built_in">read</span>(), num = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">modify</span>(x1, y1, num);</span><br><span class="line">            <span class="built_in">modify</span>(x2 + <span class="number">1</span>, y1, -num);</span><br><span class="line">            <span class="built_in">modify</span>(x1, y2 + <span class="number">1</span>, -num);</span><br><span class="line">            <span class="built_in">modify</span>(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>, num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> x1 = <span class="built_in">read</span>(), y1 = <span class="built_in">read</span>(), x2 = <span class="built_in">read</span>(), y2 = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(x2, y2)</span><br><span class="line">                - <span class="built_in">query</span>(x1 - <span class="number">1</span>, y2)</span><br><span class="line">                - <span class="built_in">query</span>(x2, y1 - <span class="number">1</span>)</span><br><span class="line">                + <span class="built_in">query</span>(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4514">洛谷 P4514 上帝造题的七分钟</a></p><div style="page-break-after:always"></div><h2 id="BIT-3- 后缀 -BIT">BIT.3 后缀 BIT</h2><p>维护后缀和。交换 <code>modify</code> 和 <code>query</code> 的跳转方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> _n)</span> </span>&#123; <span class="keyword">return</span> _n &amp; (-_n); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = i; p; p -= <span class="built_in">lowbit</span>(p)) tr[p] += num;</span><br><span class="line">&#125;  <span class="comment">// 修改 a[i] += num</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = i; p &lt; N; p += <span class="built_in">lowbit</span>(p)) res += tr[p];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;  <span class="comment">// 查询 return lst[i]</span></span><br></pre></td></tr></table></figure><p>对于可减信息，用前缀后缀 BIT 维护是一样的。但在当信息不可减且可转化为询问后缀时，能够不翻转序列地维护修改和查询。</p><h2 id="二维数点">二维数点</h2><p>给定平面内 $n$ 个点，每个点有点权，$q$ 次询问以 $(x_1,y_1)$ 为左下角，$(x_2,y_2)$ 为右上角的矩形内部（包括边界）点权之和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    ll t[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x)</span> </span>&#123; <span class="keyword">while</span> (p &lt; N) t[p] += x, p += p &amp; -p; &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; ll res = <span class="number">0</span>; <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) res += t[p], p -= p &amp; -p; <span class="keyword">return</span> res; &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>); &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">POS</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">poscmp</span><span class="params">(<span class="type">const</span> POS&amp; a, <span class="type">const</span> POS&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QUE</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, id, d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">quecmp</span><span class="params">(<span class="type">const</span> QUE&amp; a, <span class="type">const</span> QUE&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; xall, yall;  <span class="comment">// 离散化数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;POS&gt; <span class="title">pos</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), val = <span class="built_in">read</span>();</span><br><span class="line">        pos[i] = &#123; x, y, val &#125;;</span><br><span class="line"></span><br><span class="line">        xall.<span class="built_in">push_back</span>(x);</span><br><span class="line">        yall.<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(pos.<span class="built_in">begin</span>(), pos.<span class="built_in">end</span>(), poscmp);</span><br><span class="line"></span><br><span class="line">    vector&lt;QUE&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x1 = <span class="built_in">read</span>(), y1 = <span class="built_in">read</span>(), x2 = <span class="built_in">read</span>(), y2 = <span class="built_in">read</span>();</span><br><span class="line">        que.<span class="built_in">emplace_back</span>(x2, y2, i, <span class="number">1</span>);</span><br><span class="line">        que.<span class="built_in">emplace_back</span>(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">        que.<span class="built_in">emplace_back</span>(x1 - <span class="number">1</span>, y2, i, <span class="number">-1</span>);</span><br><span class="line">        que.<span class="built_in">emplace_back</span>(x2, y1 - <span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        xall.<span class="built_in">push_back</span>(x1 - <span class="number">1</span>);</span><br><span class="line">        xall.<span class="built_in">push_back</span>(x2);</span><br><span class="line">        yall.<span class="built_in">push_back</span>(y1 - <span class="number">1</span>);</span><br><span class="line">        yall.<span class="built_in">push_back</span>(y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>(), quecmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离散化</span></span><br><span class="line">    <span class="built_in">sort</span>(xall.<span class="built_in">begin</span>(), xall.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(yall.<span class="built_in">begin</span>(), yall.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        pos[i].x = <span class="built_in">lower_bound</span>(xall.<span class="built_in">begin</span>(), xall.<span class="built_in">end</span>(), pos[i].x) - xall.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">        pos[i].y = <span class="built_in">lower_bound</span>(yall.<span class="built_in">begin</span>(), yall.<span class="built_in">end</span>(), pos[i].y) - yall.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q * <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        que[i].x = <span class="built_in">lower_bound</span>(xall.<span class="built_in">begin</span>(), xall.<span class="built_in">end</span>(), que[i].x) - xall.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">        que[i].y = <span class="built_in">lower_bound</span>(yall.<span class="built_in">begin</span>(), yall.<span class="built_in">end</span>(), que[i].y) - yall.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">res</span><span class="params">(q)</span></span>;</span><br><span class="line">    <span class="type">int</span> pi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> qi = <span class="number">0</span>; qi &lt; que.<span class="built_in">size</span>(); ++qi) &#123;</span><br><span class="line">        <span class="keyword">while</span> (pi &lt; n &amp;&amp; pos[pi].x &lt;= que[qi].x) &#123;</span><br><span class="line">            bit.<span class="built_in">modify</span>(pos[pi].y, pos[pi].val);</span><br><span class="line">            ++pi;</span><br><span class="line">        &#125;</span><br><span class="line">        res[que[qi].id] += que[qi].d * bit.<span class="built_in">query</span>(que[qi].y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h1>SMT 线段树</h1><p><strong>线段树 (Segment Tree)</strong> 用于维护满足 <strong>结合律</strong> 的区间信息，支持在 $\Theta(\log n)$ 的时间内  <strong>区间修改</strong>  和  <strong>区间查询</strong>。</p><p>线段树是一棵 <strong>平衡二叉树</strong> ，树上每个 <strong>节点</strong>  $\boldsymbol{p}$ 都存储一条 <strong>线段（区间）</strong> $\boldsymbol{[l,r]}$ 的某个性质，节点 $p$ 的左右子节点的编号分别为 $2p$ 和 $2p+1$，分别储存 $[l, \mathrm{mid}]$ 和 $[\mathrm{mid}+1, r]$。</p><p>修改时，使用 <strong>懒标记</strong> $\boldsymbol{\mathrm{mark}_p}$，表示该节点 $p$ 对应的区间上每一个点都要加上某个数，用到它的 <strong>子区间</strong> 的时候，再向下 <strong>传递</strong> 修改。</p><p>预处理时间复杂度 $\Theta(n)$，查询或修改时间复杂度 $\Theta(\log n)$。</p><p>当值域为 $v$ 时，普通的线段树的空间复杂度是 $\Theta(4v)$。如果 $v$ 巨大，但查询次数 $q$ 较小时，边修改边建树，这样空间的复杂度是 $\Theta(q\log v)$。</p><p>递归的起点是区间 $[L,R]$，依数据范围修改，允许是负数。注意，这里的 <code>&gt;&gt;1</code> 不能写为 <code>/2</code>。</p><h2 id="SMT1- 单点修改">SMT1. 单点修改</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">info</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SMT</span> &#123;</span><br><span class="line">    <span class="type">int</span> L, R, p, pcnt;</span><br><span class="line">    vector&lt;info&gt; t;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ls, rs;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SMT</span>() &#123;</span><br><span class="line">        <span class="built_in">init</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        t.<span class="built_in">resize</span>(N &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        ls.<span class="built_in">resize</span>(N &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        rs.<span class="built_in">resize</span>(N &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        L = l, R = r;</span><br><span class="line">        p = pcnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        t[p] = <span class="built_in">info</span>();</span><br><span class="line">        ls[p] = rs[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> leaf (R-L&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> curr p,L,R</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls[p],L,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs[p],mid,R</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> self p,int L,int R</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        t[p] = t[ls[p]] + t[rs[p]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>&amp; self, <span class="type">const</span> vector&lt;info&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) p = ++pcnt, <span class="built_in">init</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (leaf) <span class="keyword">return</span> t[p].<span class="built_in">apply</span>(a[L]);</span><br><span class="line">        <span class="built_in">build</span>(lson, a);</span><br><span class="line">        <span class="built_in">build</span>(rson, a);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">const</span> vector&lt;info&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(curr, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单点修改</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>&amp; self, <span class="type">int</span> x, <span class="type">const</span> info&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) p = ++pcnt, <span class="built_in">init</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (leaf) <span class="keyword">return</span> t[p].<span class="built_in">apply</span>(d);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; mid) <span class="built_in">modify</span>(lson, x, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(rson, x, d);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> info&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">modify</span>(curr, x, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询[l,r)</span></span><br><span class="line">    <span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span>&amp; self, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> t[p];</span><br><span class="line">        info res;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; mid) res = res + <span class="built_in">query</span>(lson, l, r);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r) res = res + <span class="built_in">query</span>(rson, l, r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="built_in">info</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(curr, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="SMT1-1- 区间最大子段和">SMT1.1 区间最大子段和</h3><p>给定长度为 $n$ 的整数序列 $a$，有 $q$ 个询问：</p><ul><li>$1, l, r$：输出 $a_l, a_{l+1}, …, a_{r-1}$ 中的最大子段和。</li><li>$2, p, x$：将 $a_p$ 修改为 $x$。<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4513">Link</a></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    ll sum&#123; <span class="number">0</span> &#125;;       <span class="comment">// 区间和</span></span><br><span class="line">    ll lval&#123; -Inf &#125;;   <span class="comment">// 左边界必选的最大区间和</span></span><br><span class="line">    ll rval&#123; -Inf &#125;;   <span class="comment">// 右边界必选的最大区间和</span></span><br><span class="line">    ll val&#123; -Inf &#125;;    <span class="comment">// 无限制的最大区间和</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; o)</span>&amp; </span>&#123;</span><br><span class="line">        sum = lval = rval = val = o.sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        info res;</span><br><span class="line">        res.lval = <span class="built_in">max</span>(l.lval, l.sum + r.lval);</span><br><span class="line">        res.rval = <span class="built_in">max</span>(r.rval, r.sum + l.rval);</span><br><span class="line">        res.sum = l.sum + r.sum;</span><br><span class="line">        res.val = <span class="built_in">max</span>(&#123; l.val, r.val, l.rval + r.lval &#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>区间修改，区间最大子段和是 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5693">黑题</a>。</p></blockquote><h3 id="SMT1-2- 一次函数区间复合函数求值">SMT1.2 一次函数区间复合函数求值</h3><p><strong>半群</strong> 若集合 $S$ 和二元运算 $\text{op} : S \times S \rightarrow S$ 满足对任意 $x, y, z \in S$ 都有 $\text{op}(\text{op}(x, y), z) = \text{op}(x, (y, z))$, 称 $(S, \text{op})$ 为半群。因此本题为半群单点修改，区间求积 (<a target="_blank" rel="noopener" href="https://vjudge.net/problem/Yosupo-point_set_range_composite">Link</a>)</p><p>给定长度为 $n$ 的由一次函数形成的序列 $f_{i}=a_{i}x+b_{i}$，有 $q$ 个询问：</p><ul><li>$p, a, b$：将 $f_p$ 修改为 $f_p(x) = ax + b$。</li><li>$l, r, x$：求 $f_{r-1}(…f_{l+1}(f_l(x))) \bmod 998244353$。</li></ul><table><thead><tr><th>Input</th><th>Output</th></tr></thead><tbody><tr><td>5 5<br>1 2<br>3 4<br>5 6<br>7 8<br>9 10<br>1 0 5 11<br>1 2 4 12<br>0 1 13 14<br>1 0 4 15<br>1 2 5 16</td><td>14005<br>470<br>8275<br>5500</td></tr></tbody></table><ul><li><strong>维护</strong> 区间 $[l,r]$ 的 $a$ 和 $b$，即 $f_{r}(…f_{l+1}(f_l(x)))=ax+b$；</li><li><strong>修改</strong> 单点修改，无需懒标记；</li><li><strong>合并</strong> 结合复合函数 $f_{r}(f_{l}(x))=a_{r}(a_{l}x+b_{l})+b_{r}=(a_{r}a_{l})x+(a_{r}b_{l}+b_{r})$，注意复合具有方向性！即不满足交换律，$f_{r}(f_{l}(x)) \neq f_{l}(f_{r}(x))$。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    Z a&#123; <span class="number">1</span> &#125;, b&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; o)</span>&amp; </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; l.a * r.a, r.a * l.b + r.b &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">smt.<span class="built_in">modify</span>(p, &#123; a, b &#125;);</span><br><span class="line"><span class="keyword">auto</span> res = smt.<span class="built_in">query</span>(l, r);</span><br><span class="line">cout &lt;&lt; res.a * x + res.b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="SMT2- 区间修改、懒标记">SMT2. 区间修改、懒标记</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">info</span>, <span class="keyword">class</span> <span class="title class_">mark</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SMT</span> &#123;</span><br><span class="line">    <span class="type">int</span> L, R, p, pcnt;</span><br><span class="line">    vector&lt;info&gt; t;</span><br><span class="line">    vector&lt;mark&gt; m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ls, rs;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SMT</span>() &#123;</span><br><span class="line">        <span class="built_in">init</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        t.<span class="built_in">resize</span>(N &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        m.<span class="built_in">resize</span>(N &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        ls.<span class="built_in">resize</span>(N &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        rs.<span class="built_in">resize</span>(N &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        L = l, R = r;</span><br><span class="line">        p = pcnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        t[p] = <span class="built_in">info</span>();</span><br><span class="line">        m[p] = <span class="built_in">mark</span>();</span><br><span class="line">        ls[p] = rs[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> leaf (R-L&lt;2)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> curr p,L,R</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> lson ls[p],L,mid</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rson rs[p],mid,R</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> self p,int L,int R</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        t[p] = t[ls[p]] + t[rs[p]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span>&amp; self, <span class="type">const</span> mark&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) p = ++pcnt, <span class="built_in">init</span>(p);</span><br><span class="line">        t[p].<span class="built_in">apply</span>(d, L, R);</span><br><span class="line">        m[p].<span class="built_in">apply</span>(d, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span>&amp; self)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leaf) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">push_down</span>(lson, m[p]);</span><br><span class="line">        <span class="built_in">push_down</span>(rson, m[p]);</span><br><span class="line">        m[p] = <span class="built_in">mark</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建树 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>&amp; self, <span class="type">const</span> vector&lt;info&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) p = ++pcnt, <span class="built_in">init</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (leaf) <span class="keyword">return</span> t[p].<span class="built_in">apply</span>(a[L]);</span><br><span class="line">        <span class="built_in">build</span>(lson, a);</span><br><span class="line">        <span class="built_in">build</span>(rson, a);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">const</span> vector&lt;info&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(curr, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间[l,r) 修改 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>&amp; self, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> mark&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) p = ++pcnt, <span class="built_in">init</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> <span class="built_in">push_down</span>(curr, d);</span><br><span class="line">        <span class="built_in">push_down</span>(curr);</span><br><span class="line">        <span class="keyword">if</span> (l &lt; mid) <span class="built_in">modify</span>(lson, l, r, d);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r) <span class="built_in">modify</span>(rson, l, r, d);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> mark&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">modify</span>(curr, l, r, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单点修改</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>&amp; self, <span class="type">int</span> x, <span class="type">const</span> info&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) p = ++pcnt, <span class="built_in">init</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (leaf) <span class="keyword">return</span> t[p].<span class="built_in">apply</span>(d);</span><br><span class="line">        <span class="built_in">push_down</span>(curr);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; mid) <span class="built_in">modify</span>(lson, x, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(rson, x, d);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> info&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">modify</span>(curr, x, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询[l,r)</span></span><br><span class="line">    <span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span>&amp; self, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> t[p];</span><br><span class="line">        <span class="built_in">push_down</span>(curr);</span><br><span class="line">        info res;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; mid) res = res + <span class="built_in">query</span>(lson, l, r);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r) res = res + <span class="built_in">query</span>(rson, l, r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="built_in">info</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(curr, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局找满足 f 的最小下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findL</span><span class="params">(<span class="type">int</span>&amp; self, <span class="keyword">auto</span>&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">f</span>(t[p])) <span class="keyword">return</span> inf;  <span class="comment">// 整个区间不合题意</span></span><br><span class="line">        <span class="keyword">if</span> (leaf) <span class="keyword">return</span> L;        <span class="comment">// 到达叶子 返回键</span></span><br><span class="line">        <span class="built_in">push_down</span>(curr);</span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">findL</span>(lson, f);    <span class="comment">// 优先看左边</span></span><br><span class="line">        <span class="keyword">if</span> (s != inf) <span class="keyword">return</span> s;    <span class="comment">// 左边合题意</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findL</span>(rson, f);     <span class="comment">// 左边不合题意再看右边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findL</span><span class="params">(<span class="keyword">auto</span>&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findL</span>(curr, f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局找满足 f 的最大下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findR</span><span class="params">(<span class="type">int</span>&amp; self, <span class="keyword">auto</span>&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">f</span>(t[p])) <span class="keyword">return</span> -inf; <span class="comment">// 整个区间不合题意</span></span><br><span class="line">        <span class="keyword">if</span> (leaf) <span class="keyword">return</span> L;        <span class="comment">// 到达叶子 返回键</span></span><br><span class="line">        <span class="built_in">push_down</span>(curr);</span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">findR</span>(rson, f);    <span class="comment">// 优先看右边</span></span><br><span class="line">        <span class="keyword">if</span> (s != -inf) <span class="keyword">return</span> s;   <span class="comment">// 右边合题意</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findR</span>(lson, f);     <span class="comment">// 右边不合题意再看左边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findR</span><span class="params">(<span class="keyword">auto</span>&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findR</span>(curr, f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在区间[l,r) 中找满足 f 的最小下标 </span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findL</span><span class="params">(<span class="type">int</span>&amp; self, <span class="type">int</span> l, <span class="type">int</span> r, <span class="keyword">auto</span>&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r &amp;&amp; !<span class="built_in">f</span>(t[p])) <span class="keyword">return</span> inf;  <span class="comment">// 在当前区间内且不合题意</span></span><br><span class="line">        <span class="keyword">if</span> (leaf) <span class="keyword">return</span> L;                            <span class="comment">// 递归到叶 直接返回</span></span><br><span class="line">        <span class="built_in">push_down</span>(curr);</span><br><span class="line">        <span class="keyword">if</span> (l &lt; mid) &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="built_in">findL</span>(lson, l, r, f);            <span class="comment">// 先向左递归找</span></span><br><span class="line">            <span class="keyword">if</span> (res != inf) <span class="keyword">return</span> res;                <span class="comment">// 左边不是 -1 说明左边有解 那不用管右边了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r) <span class="keyword">return</span> <span class="built_in">findL</span>(rson, l, r, f);      <span class="comment">// 左边无解再看右边</span></span><br><span class="line">        <span class="keyword">return</span> inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findL</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="keyword">auto</span>&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findL</span>(curr, l, r, f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在区间[l,r) 中找满足 f 的最大下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findR</span><span class="params">(<span class="type">int</span>&amp; self, <span class="type">int</span> l, <span class="type">int</span> r, <span class="keyword">auto</span>&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r &amp;&amp; !<span class="built_in">f</span>(t[p])) <span class="keyword">return</span> -inf; <span class="comment">// 在当前区间内且不合题意</span></span><br><span class="line">        <span class="keyword">if</span> (leaf) <span class="keyword">return</span> L;                            <span class="comment">// 递归到叶 直接返回</span></span><br><span class="line">        <span class="built_in">push_down</span>(curr);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="built_in">findR</span>(rson, l, r, f);            <span class="comment">// 先向右递归找</span></span><br><span class="line">            <span class="keyword">if</span> (res != -inf) <span class="keyword">return</span> res;               <span class="comment">// 右边不是 -1 说明右边有解 那不用管左边了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; mid) <span class="keyword">return</span> <span class="built_in">findR</span>(lson, l, r, f);      <span class="comment">// 右边无解再看左边</span></span><br><span class="line">        <span class="keyword">return</span> -inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findR</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="keyword">auto</span>&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findR</span>(curr, l, r, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="SMT2-1- 区间乘、区间加，区间和">SMT2.1 区间乘、区间加，区间和</h3><p><strong>自同态</strong> 若 $f : S \rightarrow S$ 满足对任意 $x, y \in S$, $f(\text{op}(x, y)) = \text{op}(f(x), f(y))$, 称 $f$ 为 $S$ 的自同态。$S$ 所有自同态的集合记为 $\text{End}(S)$。所以这也叫半群区间自同态作用，区间求积（？</p><p>给定长度为 $n$ 的整数序列 $a$，有 $q$ 个询问：</p><ul><li>$0, l, r, b, c$：对所有 $i \in [l, r)$, 将 $a_i$ 修改为 $a_i \times b + c$。</li><li>$1, l, r, b$：对所有 $i \in [l, r)$, 将 $a_i$ 修改为 $a_i \times b$。</li><li>$2, l, r, c$：对所有 $i \in [l, r)$, 将 $a_i$ 修改为 $a_i + c$。</li><li>$3, l, r$：求 $\sum_{i=l}^{r-1} a_i \bmod 571373$。<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3373">Link</a></li></ul><p>区间乘、区间加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mark</span> &#123;</span><br><span class="line">    Z mul&#123; <span class="number">1</span> &#125;;   <span class="comment">// 乘法标记</span></span><br><span class="line">    Z add&#123; <span class="number">0</span> &#125;;   <span class="comment">// 加法标记</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        mul *= o.mul;</span><br><span class="line">        add = add * o.mul + o.add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    Z sum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        sum *= o.mul;</span><br><span class="line">        sum += o.add * s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; o)</span>&amp; </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; l.sum + r.sum &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">0</span>) smt.<span class="built_in">modify</span>(l, r, &#123; <span class="built_in">read</span>(), <span class="built_in">read</span>() &#125;);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) smt.<span class="built_in">modify</span>(l, r, &#123; <span class="built_in">read</span>(), <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">2</span>) smt.<span class="built_in">modify</span>(l, r, &#123; <span class="number">1</span>, <span class="built_in">read</span>() &#125;);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">3</span>) cout &lt;&lt; smt.<span class="built_in">query</span>(l, r).sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>应用：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4247">VJspr15H - 序列操作</a></p><p>长度为 $n$ 的序列，有三种操作：</p><ol><li><code>I a b c</code> 表示将 $[a,b]$ 这一段区间的元素集体增加 $c$；</li><li><code>R a b</code>表示将 $[a,b]$ 区间内所有元素变成相反数；</li><li><code>Q a b c</code> 表示询问 $[a,b]$ 这一段区间中选择 $c$ 个数相乘的所有方案的和 $\bmod 19940417$ 的值。</li></ol><table><thead><tr><th>Input</th><th>Output</th></tr></thead><tbody><tr><td>5 5<br>1 2 3 4 5<br>I 2 3 1<br>Q 2 4 2<br>R 1 5<br>I 1 3 -1<br>Q 1 5 1</td><td>40<br>19940397</td></tr></tbody></table><p>数据范围：$n \leqslant 50000$，$q \leqslant 50000$，初始 $|a_{i}|\leqslant 10^9$，<code>I</code> 操作中 $|c| \leqslant 10^9$，<code>Q</code> 操作中 $1 \leqslant c \leqslant \min(b-a+1,20)$。</p><p><strong>维护什么？</strong><br>设 $f_{c}$ 为选择 $c$ 个数相乘的所有方案的和，这具有递推性，直接维护所有的答案 $f_{c}\ (1 \leqslant c \leqslant 20)$。</p><p><strong>如何更新？</strong><br><code>push_up</code>：选择 $c$ 个数，可以左边选 $i$ 个，右边选 $c-i$ 个，结果应当是相乘，即<br>$$<br>p.f_{c}=\sum_{i=0}^{20}l.f_{i}\cdot r.f_{c-i}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(seg&amp; p, seg l, seg r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        p.f[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            p.f[i] += l.f[j] * r.f[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间变成相反数是区间乘的简化版，考察区间乘和区间加对 $f$ 的影响：</p><ul><li>根据上一题的结论，懒标记的下传应当先乘再加；</li><li>区间 $\times d$ 后，选择 $c$ 个数相乘的所有方案的和 $f_{c}\leftarrow f_{c}\times d^{c}$，子节点的两种懒标记都 $\times d$；</li><li>区间 $+d$ 后，选择 $c$ 个数相乘的所有方案的和的变化比较复杂，假设我们选出的数是 $a_{1},a_{2},\dots, a_{c}$，原先对答案的贡献是 $S_{c}=\prod\limits_{i=1}^{c} a_{i}$，区间 $+d$ 后，对答案的贡献是 $S’<em>{c}=\prod\limits</em>{i=1}^{c} (a_{i}+d)$，对答案的贡献的增量 $$\Delta S_{c}=\sum_{k=0}^{c}d^{k}\operatorname{C}<em>{n-(c-k)}^{k}\prod a$$，因此答案的总增量可以表示为 $$<br>\Delta f</em>{c}=\sum_{k=0}^{c}d^{k}\operatorname{C}<em>{n-(c-k)}^{k}f</em>{i-k}$$ 预处理组合数，根据递推式二重循环即可。</li></ul><p>时间复杂度 $\Theta(m^{2}n\log n)$，其中 $m=20$，常数较大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">8</span>, M = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">using</span> Z = ModInt&lt;<span class="number">19940417</span>&gt;;</span><br><span class="line">Z C[N][M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">beforeT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; M) C[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i &amp;&amp; j &lt; M; ++j)</span><br><span class="line">            C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mark</span> &#123;</span><br><span class="line">    Z mul&#123; <span class="number">1</span> &#125;;   <span class="comment">// 乘法标记</span></span><br><span class="line">    Z add&#123; <span class="number">0</span> &#125;;   <span class="comment">// 加法标记</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        mul *= o.mul;</span><br><span class="line">        add = add * o.mul + o.add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    vector&lt;Z&gt; sum;</span><br><span class="line">    <span class="built_in">info</span>(Z a0 = <span class="number">0</span>, Z a1 = <span class="number">0</span>) &#123;</span><br><span class="line">        sum.<span class="built_in">resize</span>(M);</span><br><span class="line">        sum[<span class="number">0</span>] = a0;</span><br><span class="line">        sum[<span class="number">1</span>] = a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o.mul == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = M - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; <span class="number">1</span>) sum[i] *= o.mul;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o.add.<span class="built_in">vale</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = M - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s - i + j &gt;= <span class="number">0</span>)</span><br><span class="line">                        sum[i] +=</span><br><span class="line">                        C[s - i + j][j]</span><br><span class="line">                        * ((o.add).<span class="built_in">pow</span>(j))</span><br><span class="line">                        * sum[i - j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; o)</span>&amp; </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        info res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">            res.sum[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                res.sum[i] += l.sum[j] * r.sum[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">beforeT</span>();</span><br><span class="line">    SMT&lt;info, mark&gt; smt;</span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">        smt.<span class="built_in">modify</span>(i, info&#123; <span class="number">1</span>, x &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">char</span> op = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;I&#x27;</span>) smt.<span class="built_in">modify</span>(l, r, &#123; <span class="number">1</span>, <span class="built_in">read</span>() &#125;);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;R&#x27;</span>) smt.<span class="built_in">modify</span>(l, r, &#123; <span class="number">-1</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;Q&#x27;</span>) cout &lt;&lt; smt.<span class="built_in">query</span>(l, r).sum[<span class="built_in">read</span>()] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SMT2-2- 区间加，区间平方和">SMT2.2 区间加，区间平方和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mark</span> &#123;</span><br><span class="line">    <span class="type">double</span> add&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        add += o.add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    <span class="type">double</span> sum&#123; <span class="number">0</span> &#125;, ssq&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        ssq += <span class="number">2</span> * o.add * sum + o.add * o.add * s;</span><br><span class="line">        sum += o.add * s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; o)</span>&amp; </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; l.sum + r.sum, l.ssq + r.ssq &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1471">区间方差</a></p><p>$$<br>S^{2}=\dfrac{1}{n}\sum(x_{i}-\bar{x})^{2}=\dfrac{1}{n}\sum x_{i}^{2}-\bar{x}^{2}<br>$$</p><h3 id="SMT2-3- 区间赋值，区间和">SMT2.3 区间赋值，区间和</h3><p>603 教室里有 $n$ 盏灯，从左到右依次编号为：$1,2,\dots,n$，初始时都是开着的。人走灯灭，下课后，$m$ 个同学依次经过灯的开关，每个人会执行以下两种操作中的一种：</p><ul><li>操作 $1$：关上从 $l$ 到 $r$（含边界）范围内的所有灯；</li><li>操作 $2$：打开从 $l$ 到 $r$（含边界）范围内的所有灯。</li></ul><p>请你帮助班长计算，为了关上所有的灯，他还需要关上几盏灯。</p><p>数据范围：$1  \leqslant  n \leqslant 10^9, \quad 1  \leqslant  m \leqslant  3·10^{5}, \quad 1  \leqslant  l_{i},r_{i} \leqslant  n, \quad 1  \leqslant  k_{i} \leqslant  2$，本题的内存限制为 256 megabytes。(<a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/915/E">VJsum1B. Physical Education Lessons</a>)</p><p>为优化阅读体验，重写了题目描述。——KobicGend</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mark</span> &#123;</span><br><span class="line">    <span class="type">int</span> asn&#123; <span class="number">-1</span> &#125;;  <span class="comment">// 赋值标记</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (~o.asn) asn = o.asn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (~o.asn) sum = o.asn * s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; o)</span>&amp; </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; l.sum + r.sum &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">    SMT&lt;info, mark&gt; smt;</span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">1</span>, n);</span><br><span class="line">    smt.<span class="built_in">modify</span>(<span class="number">1</span>, n, &#123; <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q = <span class="built_in">read</span>(); q--;) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), op = <span class="built_in">read</span>();</span><br><span class="line">        smt.<span class="built_in">modify</span>(l, r, &#123; op - <span class="number">1</span> &#125;);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, smt.<span class="built_in">query</span>(<span class="number">1</span>, n).sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h3 id="SMT2-4- 区间赋值、区间加，区间最值及其个数">SMT2.4 区间赋值、区间加，区间最值及其个数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mark</span> &#123;</span><br><span class="line">    <span class="type">int</span> asn&#123; <span class="number">-1</span> &#125;;  <span class="comment">// 赋值标记</span></span><br><span class="line">    <span class="type">int</span> add&#123; <span class="number">0</span> &#125;;   <span class="comment">// 加法标记</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        <span class="comment">// 先赋值再加法</span></span><br><span class="line">        <span class="keyword">if</span> (~o.asn) &#123;</span><br><span class="line">            asn = o.asn;</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        add += o.add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    <span class="type">int</span> mn&#123; <span class="number">0</span> &#125;;  <span class="comment">// 最小值</span></span><br><span class="line">    <span class="type">int</span> tot&#123; <span class="number">0</span> &#125;; <span class="comment">// 最小值的个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (~o.asn) mn = o.asn;</span><br><span class="line">        mn += o.add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; o)</span>&amp; </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l.mn &lt; r.mn) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">if</span> (l.mn &gt; r.mn) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> &#123; l.mn, l.tot + r.tot &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>例 1</strong> 给定 $n$ 个点、$n$ 条双向边的环。有 $m$ 对点对 $a_i,b_i$，要求删掉尽可能多的边，使得删完后，每对 $a_i,b_i$ 仍联通。求出剩余边数的最小值。(<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1996/problem/G">CF1996G. Penacony</a>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mark</span> &#123;</span><br><span class="line">    <span class="type">int</span> add&#123; <span class="number">0</span> &#125;;   <span class="comment">// 加法标记</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        add += o.add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    <span class="type">int</span> mn&#123; <span class="number">0</span> &#125;;  <span class="comment">// 最小值</span></span><br><span class="line">    <span class="type">int</span> tot&#123; <span class="number">1</span> &#125;; <span class="comment">// 最小值的个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        mn += o.add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; o)</span>&amp; </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l.mn &lt; r.mn) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">if</span> (l.mn &gt; r.mn) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> &#123; l.mn, l.tot + r.tot &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SMT&lt;info, mark&gt; smt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">1</span>, n &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span></span>;</span><br><span class="line">    smt.<span class="built_in">build</span>(t);  <span class="comment">// 先把叶子的 tot 设为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(m)</span>, <span class="title">b</span><span class="params">(m)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pos</span>(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>(), b[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; b[i]) <span class="built_in">swap</span>(a[i], b[i]);</span><br><span class="line">        smt.<span class="built_in">modify</span>(a[i], b[i] - <span class="number">1</span>, &#123; <span class="number">1</span> &#125;);</span><br><span class="line">        pos[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = smt.<span class="built_in">query</span>(j, j + n - <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (res.mn == <span class="number">0</span>) * res.tot);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : pos[j]) &#123;</span><br><span class="line">            smt.<span class="built_in">modify</span>(a[i], b[i] - <span class="number">1</span>, &#123; <span class="number">-1</span> &#125;);</span><br><span class="line">            <span class="built_in">swap</span>(a[i], b[i]);</span><br><span class="line">            b[i] += n;</span><br><span class="line">            smt.<span class="built_in">modify</span>(a[i], b[i] - <span class="number">1</span>, &#123; <span class="number">1</span> &#125;);</span><br><span class="line">            pos[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n - ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SMT-3- 线段树二分">SMT.3 线段树二分</h2><p>对于朴素二分，每次 <code>check</code> 需查询单点前缀和，一次询问复杂度 $\Theta(\log^{2}n)$；而线段树的分治结构 <strong>合并二分和查询的过程</strong>，实现 $\Theta(\log n)$ 的复杂度。</p><p><strong>例 1</strong> 给定一个长度为 $n$ 的序列 $a_i\ (1\leqslant i\leqslant n)$，参数 $B$，询问数 $q$。每一次询问首先给出两个整数 $c$ 和 $x$，表示将序列的第 $c$ 个数字永久地修改为 $x$，然后你需要按如下规则输出一个实数：</p><ol><li>如果不存在某一个前缀平均值不低于 $B$，则输出整体平均值；</li><li>否则，输出第一个不低于 $B$ 的前缀平均值。</li></ol><p>其中，序列的第 $k$ 个前缀平均值定义为 $s_k=\dfrac1k\sum\limits_{i=1}^{k}a_i$，整体平均值为 $s_n$。</p><p>数据范围：$1 \leqslant n \leqslant 5 \times 10^5,\quad1 \leqslant q \leqslant 10^5,\quad0 \leqslant a_i,x,B \leqslant 10^9,\quad1 \leqslant c \leqslant n$(VJsum1F. <a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc292/tasks/abc292_h?lang=en">abc292Ex - Rating Estimator</a>)</p><p><strong>思路</strong> 将所有数减去 $B$，前缀平均值 $\geqslant B$ 转化为前缀和 $\geqslant 0$，需要找到第一个 $\geqslant 0$ 的前缀。（很经典的分式化整式，回忆 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1419">洛谷 P1419 寻找段落</a>）</p><p>线段树维护（下标，前缀和序列区间最大值），二分求解，对于某个节点 $p$，如果在左儿子对应的区间上找到了一个区间最大值 $\geqslant 0$ 的，那答案在左儿子，否则在右儿子上找 $\geqslant 0$ 的，如果都找不到，就说明所求不存在。只有单点修改，对于前缀和序列来说，就是进行了一次 <strong>区间加</strong>。（题设没有区间修改，间接证明了这种方法的合理性）</p><p>时间复杂度 $\Theta((n+q)\log n)$，空间 $\Theta(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mark</span> &#123;</span><br><span class="line">    ll add&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; d, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        add += d.add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    ll mx&#123; (ll)<span class="number">-1e18</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; d, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        mx += d.add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; o)</span>&amp; </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="built_in">max</span>(l.mx, r.mx) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, B, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; B &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    SMT&lt;info, mark&gt; smt;</span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] -= B;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;info&gt; <span class="title">pre</span><span class="params">(n)</span></span>;</span><br><span class="line">    pre[<span class="number">0</span>].mx = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) pre[i].mx = pre[i - <span class="number">1</span>].mx + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    smt.<span class="built_in">build</span>(pre);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> c, x;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; x;</span><br><span class="line">        c--;</span><br><span class="line">        x -= B;</span><br><span class="line"></span><br><span class="line">        smt.<span class="built_in">modify</span>(c, n, &#123; x - a[c] &#125;);</span><br><span class="line">        a[c] = x;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pos = smt.<span class="built_in">findL</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; p) &#123;</span><br><span class="line">            <span class="keyword">return</span> p.mx &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (pos == inf) pos = n - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.15lf\n&quot;</span>, <span class="number">1.0</span> * smt.<span class="built_in">query</span>(pos, pos + <span class="number">1</span>).mx / (pos + <span class="number">1</span>) + B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><p><strong>例 2</strong> <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2000/problem/H">CF2000H. Ksyusha and the Loaded Set</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mark</span> &#123;</span><br><span class="line">    <span class="type">int</span> asn&#123; <span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (~o.asn) asn = o.asn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    <span class="type">int</span> mx&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (~o.asn) mx = o.asn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; o, <span class="type">int</span> s)</span>&amp; </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = o;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="built_in">max</span>(l.mx, r.mx) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SMT&lt;info, mark&gt; smt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> L = <span class="number">0</span>, R = <span class="number">2e6</span> + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    smt.<span class="built_in">init</span>(L, R);</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(L), s.<span class="built_in">insert</span>(R);</span><br><span class="line">    <span class="type">int</span> lst = L, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        now = <span class="built_in">read</span>();</span><br><span class="line">        smt.<span class="built_in">modify</span>(lst, lst, &#123; now - lst - <span class="number">1</span> &#125;);</span><br><span class="line">        s.<span class="built_in">insert</span>(now);</span><br><span class="line">        lst = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">char</span> c; <span class="keyword">do</span> c = <span class="built_in">getchar</span>(); <span class="keyword">while</span> (c != <span class="string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="string">&#x27;?&#x27;</span> &amp;&amp; c != <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="keyword">auto</span> it = s.<span class="built_in">find</span>(x);</span><br><span class="line">            <span class="type">int</span> l = *<span class="built_in">prev</span>(it), r = *<span class="built_in">next</span>(it);</span><br><span class="line">            smt.<span class="built_in">modify</span>(l, l, &#123; x - l - <span class="number">1</span> &#125;);</span><br><span class="line">            smt.<span class="built_in">modify</span>(x, x, &#123; r - x - <span class="number">1</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = s.<span class="built_in">find</span>(x);</span><br><span class="line">            <span class="type">int</span> l = *<span class="built_in">prev</span>(it), r = *<span class="built_in">next</span>(it);</span><br><span class="line">            s.<span class="built_in">erase</span>(x);</span><br><span class="line">            smt.<span class="built_in">modify</span>(l, l, &#123; r - l - <span class="number">1</span> &#125;);</span><br><span class="line">            smt.<span class="built_in">modify</span>(x, x, &#123; <span class="number">0</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> res = smt.<span class="built_in">findL</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; p) &#123;</span><br><span class="line">                <span class="keyword">return</span> p.mx &gt;= x;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (res == R + <span class="number">1</span>) res = *<span class="built_in">next</span>(s.<span class="built_in">rbegin</span>());</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, res + <span class="number">1</span>, <span class="string">&quot; \n&quot;</span>[q == <span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例 3</strong> 给定序列 $a$ 和序列 $b$，长度均为 $n$。问有多少组 $(l,r)$，满足 $1 \leqslant l \leqslant r \leqslant n$ 且<br>$$<br>\max\limits_{l \leqslant i \leqslant r}\lbrace a_{i} \rbrace = \min\limits_{l \leqslant i \leqslant r}\lbrace b_{i} \rbrace<br>$$</p><p>数据范围：$n \leqslant 2\times 10^5$，$|a_i|,|b_i| \leqslant 10^9$。(<a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/689/D">CF689D - Friends and Subsequences</a>)</p><p><strong>思路</strong> 固定 $l$，计算满足条件的 $r$ 的个数，注意到 $\max\limits_{l \leqslant i \leqslant p_{1}}\lbrace a_{i} \rbrace$ 是关于 $p_{1}$ 单调增的，$\min\limits_{l \leqslant i \leqslant p_{1}}\lbrace b_{i} \rbrace$ 是关于 $p_{2}$ 单调减的，因此必然存在一组 $p_{1},p_{2}$，使得答案在 $[p_{1},p_{2})$ 之间，具体的，</p><ul><li>$p_{1}$ 为满足 $\max\limits_{l \leqslant i \leqslant p_{1}}\lbrace a_{i} \rbrace \geqslant \min\limits_{l \leqslant i \leqslant p_{1}}\lbrace b_{i} \rbrace$ 的最小的下标；</li><li>$p_{2}$ 为满足 $\max\limits_{l \leqslant i \leqslant p_{2}}\lbrace a_{i} \rbrace &gt; \min\limits_{l \leqslant i \leqslant p_{2}}\lbrace b_{i} \rbrace$ 的最小的下标，也即 $p_{2}-1$ 为满足 $\max\limits_{l \leqslant i \leqslant p_{2}-1}\lbrace a_{i} \rbrace \leqslant \min\limits_{l \leqslant i \leqslant p_{2}-1}\lbrace b_{i} \rbrace$ 的最大的下标。</li></ul><p>用 ST 表二分或线段树二分实现，虽然不涉及修改，但线段树二分能省去一个 $\log$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mark</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; d, <span class="type">int</span> s)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    <span class="type">int</span> amx&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> bmn&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; d, <span class="type">int</span> s)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; d, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = d;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="built_in">max</span>(l.amx, r.amx), <span class="built_in">min</span>(l.bmn, r.bmn) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    SMT&lt;info, mark&gt; smt;</span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;info&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i].amx = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i].bmn = <span class="built_in">read</span>();</span><br><span class="line">    smt.<span class="built_in">build</span>(a);</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">-0x3f3f3f3f</span>, mn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="type">int</span> p1 = smt.<span class="built_in">findL</span>(i, n, [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; p) &#123;</span><br><span class="line">            <span class="comment">// 找满足 max&#123;a[i~p]&#125; &gt;= min&#123;b[i~p]&#125; 的最小 p</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">max</span>(mx, p.amx) &gt;= <span class="built_in">min</span>(mn, p.bmn)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, p.amx);</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, p.bmn);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        mx = <span class="number">-0x3f3f3f3f</span>, mn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="type">int</span> p2 = smt.<span class="built_in">findL</span>(i, n, [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; p) &#123;</span><br><span class="line">            <span class="comment">// 找满足 max&#123;a[i~p]&#125; &gt; min&#123;b[i~p]&#125; 的最小 p</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">max</span>(mx, p.amx) &gt; <span class="built_in">min</span>(mn, p.bmn)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, p.amx);</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, p.bmn);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res += p2 - p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例 4</strong> 有 $n$ 个商店，去第 $i$ 个商店购买物品需要花费 $a_{i}$ 元，保证 $a$ 序列为非增序列。两种操作：</p><ol><li>对所有的 $i\in[1, x]$，令 $a_{i} \leftarrow \max\lbrace a_{i}, y \rbrace$；</li><li>你有 $y$ 元钱，从编号为 $x$ 的商店出发，依次遍历所有商店直至到 $n$ 号商店为止，如果能购买当前商店的物品则购买。问你能买多少物品。</li></ol><p>数据范围：$0\leqslant n,q\leqslant 20000,\quad 0\leqslant a_{i},y\leqslant 10^9$。(VJsum1G. <a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1440/E">CF1440E. Greedy Shopping</a>)</p><p><strong>思路</strong> 题给初始序列单调不增，进一步考察，序列在任意时刻都 <strong>单调不增</strong>。（题目的每个条件都是有用的）</p><p>操作 1，对 $[1, x]$ <strong>区间赋值</strong> 。由于序列单调不增，因此存在一个分界线，它左边都不需要修改，右边都需要修改。这个分界线由 <strong>二分</strong> 获得，具体来说，</p><ul><li>如果当前区间的最小值 $&gt;y$，则不需要修改；</li><li>如果当前区间的最大值 $&lt;y$，则应当修改；</li><li>否则无法判断，继续递归。</li></ul><p>操作 2，进行询问区间 $[x, n]$。因为购买的区间不一定连续，不能直接用线段树二分返回某个特定的下标，而是应当将所有满足条件的记录下来，具体来说，</p><ul><li>如果当前区间的最小值 $&lt;y$，则一个都买不起，返回；</li><li>如果当前区间的和 $\geqslant y$，全买，买了区间长度个，花费区间和的费用，更新这两个数值，返回；</li><li>否则买其中一部分，继续递归。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SMT</span> &#123;</span><br><span class="line">    <span class="type">int</span> pcnt;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> L, R, rt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">        ll sum;     <span class="comment">// 区间和 </span></span><br><span class="line">        <span class="type">int</span> mn, mx; <span class="comment">// 区间最值</span></span><br><span class="line">        ll mrk;     <span class="comment">// 懒标记</span></span><br><span class="line">        <span class="type">int</span> len;    <span class="comment">// 区间长度</span></span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">    &#125; t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        pcnt = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line">        L = l, R = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        t[p] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls t[p].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs t[p].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((cl+cr)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len (cr-cl+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls,cl,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs,mid+1,cr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这两个函数中写需要维护的东西</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(info&amp; p, info l, info r)</span> </span>&#123;</span><br><span class="line">        p.sum = l.sum + r.sum;</span><br><span class="line">        p.mx = <span class="built_in">max</span>(l.mx, r.mx);</span><br><span class="line">        p.mn = <span class="built_in">min</span>(l.mn, r.mn);</span><br><span class="line">        p.len = l.len + r.len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(info&amp; p, ll d, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">        p.sum = d * l;</span><br><span class="line">        p.mx = p.mn = p.mrk = d;</span><br><span class="line">        p.len = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">push_up</span>(t[p], t[ls], t[rs]); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t[p].mrk) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ls) ls = ++pcnt, <span class="built_in">init</span>(ls);</span><br><span class="line">        <span class="built_in">push_down</span>(t[ls], t[p].mrk, l - (l &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (!rs) rs = ++pcnt, <span class="built_in">init</span>(rs);</span><br><span class="line">        <span class="built_in">push_down</span>(t[rs], t[p].mrk, l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        t[p].mrk = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="keyword">auto</span>&amp; a, <span class="type">int</span>&amp; p = rt, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) p = ++pcnt, <span class="built_in">init</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (cl == cr) <span class="keyword">return</span> <span class="built_in">push_down</span>(p, a[cl], <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">build</span>(a, lson), <span class="built_in">build</span>(a, rson);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d, <span class="type">int</span>&amp; p = rt, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[p].mn &gt;= d) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (t[p].mx &lt; d)  <span class="keyword">return</span> <span class="built_in">push_down</span>(t[p], d, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, len);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(l, r, d, lson);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r)  <span class="built_in">modify</span>(l, r, d, rson);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在区间[l,r] 中找到满足 f 的全部位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="keyword">auto</span>&amp;&amp; f, <span class="type">int</span>&amp; p = rt, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r &amp;&amp; !<span class="built_in">f</span>(t[p])) <span class="keyword">return</span>;  <span class="comment">// 在当前区间内且不合题意</span></span><br><span class="line">        <span class="built_in">push_down</span>(p, len);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">findin</span>(l, r, f, lson);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r)  <span class="built_in">findin</span>(l, r, f, rson);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> SMT::L, SMT::R, SMT::rt;</span><br><span class="line">SMT smt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        arr[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    smt.<span class="built_in">build</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            smt.<span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            smt.<span class="built_in">findin</span>(x, n, [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (y &lt; p.mn) <span class="keyword">return</span> <span class="number">0</span>;        <span class="comment">// 一个都买不起</span></span><br><span class="line">                <span class="keyword">if</span> (y &gt;= p.sum) &#123;</span><br><span class="line">                    y -= p.sum, res += p.len;  <span class="comment">// 全买了 买了 cr-cl+1 个，花费 t[p].sum</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;                       <span class="comment">// 买部分 继续递归</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SMT-4- 权值线段树">SMT.4 权值线段树</h2><p>用线段树维护 <strong>桶</strong>，在 $\Theta(\log v)$ 的时间内查询某个范围内的数出现的总次数、第 $k$ 大数、前驱后继等。空间复杂度 $\Theta(q\log v)$。</p><p>权值线段树无需懒标记 <code>mrk</code>，由于是单点更新，也无需 <code>push_down</code> 和 <code>push_up</code> 函数，而是递归到底、区间相加，代码相对于普通线段树更短，这也是较 <strong>平衡树</strong> 的优势，但是当值域较大、询问较多时空间占用较大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countl</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query</span>(L, x - <span class="number">1</span>).val; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query</span>(x + <span class="number">1</span>, R).val; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rankof</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">countl</span>(x) + <span class="number">1</span>; &#125;  <span class="comment">// 排名 (比当前数小的数的个数 +1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kthnum</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> p = rt, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;  <span class="comment">// 指定排名的数</span></span><br><span class="line">    <span class="keyword">if</span> (cl == cr) <span class="keyword">return</span> cl;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= t[ls].val) <span class="keyword">return</span> <span class="built_in">kthnum</span>(k, lson);  <span class="comment">// 往左搜</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kthnum</span>(k - t[ls].val, rson);  <span class="comment">// 往右搜</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prenum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">kthnum</span>(<span class="built_in">countl</span>(x)); &#125;  <span class="comment">// 前驱</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sucnum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">kthnum</span>(t[rt].val - <span class="built_in">countg</span>(x) + <span class="number">1</span>); &#125;  <span class="comment">// 后继</span></span><br></pre></td></tr></table></figure><p><strong>例 1</strong> 两个人用石头博弈，共 $n$ 种石头，每种石头有两块，价值分别为 $a_{i},\ b_{i}$。A 和 B 按照 ABBAABBAABBA 的顺序依次购买一块石头。</p><p>规定：</p><ul><li>每种石头每个人只能买一次，即对于每种石头，要么买第一块，要么买第二块；</li><li>对于每种石头，只有当第一块被买走才能买第二块。</li></ul><p>两个人都最小化买齐 $n$ 种石头的花费，求 A 的最小花费。按顺序给出 $m$ 次永久修改，每次修改给出这个答案。(<a target="_blank" rel="noopener" href="https://codeforces.com/gym/104160/problem/I">VJsum1A &amp; 2022 ICPC 沈阳 I. Quartz Collection</a>)</p><blockquote><p>当时完美地解决了 Step1，但是不会线段树。</p></blockquote><p><strong>Step1 假博弈真贪心</strong></p><p>这部分比较简单。</p><p>称 $a_{i} - b_{i}$ 为 <em>代价</em>，两个人均希望代价尽可能小，故按代价从小到大排序。</p><ul><li>对于 $a_{i} \leqslant b_{i}$ 的部分，两人均优先买第一块，于是按购买顺序依次买第一块，即 A 买 $a_{0}$，B 买 $a_{1}$，B 买 $a_{2}$，A 买 $a_{3}$…… A 买到的第一块石头的下标 $i,\ i \equiv 0, 3 \pmod 4$。</li><li>对于 $a_{i} &gt; b_{i}$ 的部分，两人均避免买第一块，于是能买第二块就买第二块，否则选择代价最小的第一块购买。考虑 $a_{i} \leqslant b_{i}$ 都买完后轮到了谁：<ul><li>若 $a_{i} \leqslant b_{i}$ 的数量为奇数，设有 $m$ 个。<br>这部分的购买情况是 ABB / AAB / BAABBAA… 或 ABBAA / BBAAB / BAABBAA…，无论哪种情况，$a_{i} \leqslant b_{i}$ 都买完后都轮到了 B，且为 BAABBAA。<br>于是 B 先买代价最小的 $a_{m}$，然后 A 买对应的第二块 $b_{m}$，再买 $a_{m+1}$，B 买 $b_{m+1},\ a_{m+2}$……<br>A 买到的第一块石头的下标 $i,\ i-m \equiv 1, 3 \pmod 4$。</li><li>若 $a_{i} \leqslant b_{i}$ 的数量为偶数，类似地分析，ABBA / ABBA / ABBAABB，$a_{i} \leqslant b_{i}$ 都买完后都轮到了 A，于是 A 买到的第一块石头的下标 $i,\ i-m \equiv 0, 2 \pmod 4$。<br>将上面两部分的结果相加，再加上 $\sum b_{i}$，即是答案。</li></ul></li></ul><p><strong>Step2 线段树</strong></p><p>首先明确，因涉及排名，我们需要建立 <strong>权值线段树</strong>，具体地，以代价 $a_{i} - b_{i}$ 建立权值线段树。</p><p><strong>维护什么？</strong></p><ul><li>每个数出现的次数 <code>siz</code>，常规的权值线段树。</li><li>排名为 $i$ 的数的总和，记为 <code>sum[4]</code>，其中 <code>tr[p].sum[k]</code> 表示节点 $p$ 对应的区间 $[l,r]$ 中，排名为 $i,\ i \equiv k \pmod 4$ 的数的总和。</li></ul><p><strong>如何更新？</strong> 考察两个方面，即 <code>push_up</code> 和对叶的操作。</p><ul><li><code>push_up</code>：<ul><li>对于 <code>siz</code>，常规操作，<code>tr[p].siz = tr[ls].siz + tr[rs].siz</code>；</li><li>对于 <code>sum[4]</code>，感性地理解一下，不难得到 <code>tr[p].sum[i] = tr[ls].sum[i] + tr[rs].sum[i-m]</code>，即左节点排名为 $i,\ i \equiv k$ 的总和加上右节点排名为 $i,\ i-m \equiv k$ 的总和相加，其中 $m$ 是左节点的数的数量。</li></ul></li><li>对叶的操作：<ul><li>对于 <code>siz</code>，常规操作，<code>tr[p].siz += d</code>；</li><li>对于 <code>sum[4]</code>，因为叶只有一个数，那排名就是 0，容易想到 <code>tr[p].val[0] += x * d</code>，但这样是错误的，原因是 <strong>相同的数也应当要排名</strong>，具体写法参见代码。</li></ul></li></ul><p><strong>如何查询？</strong></p><ul><li>注意到查询只需要查询根节点 $\mathrm{rt}$，所以只需写一个简略的函数：置值域为 $[-10^{5},10^{5}]$，这样，根节点的左儿子即是 $a_{i} - b_{i} \leqslant 0$，右儿子即是 $a_{i} - b_{i} &gt; 0$，<strong>天然地将树分成了两块</strong>。根据 Step1 的推断，对于左儿子，查询 <code>sum[0] + sum[3]</code>，对于右儿子，视左儿子的节点个数分情况讨论，再将两者求和即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SMT</span> &#123;</span><br><span class="line">    <span class="type">int</span> pcnt;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> L, R, rt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">        <span class="type">int</span> siz;</span><br><span class="line">        ll sum[<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">    &#125; t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        pcnt = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line">        L = l, R = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        t[p] = &#123; <span class="number">0</span>, &#123;<span class="number">0</span>&#125;, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls t[p].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs t[p].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((cl+cr)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len (cr-cl+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls,cl,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs,mid+1,cr</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span>&amp; p = rt)</span> </span>&#123;</span><br><span class="line">        t[p].siz = t[ls].siz + t[rs].siz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            t[p].sum[i] = t[ls].sum[i] + t[rs].sum[((i - t[ls].siz) % <span class="number">4</span> + <span class="number">4</span>) % <span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d, <span class="type">int</span>&amp; p = rt, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) p = ++pcnt, <span class="built_in">init</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (cl == cr) &#123;  <span class="comment">// 叶子的处理</span></span><br><span class="line">            <span class="comment">// WA: t[p].sum[0] += x * d;</span></span><br><span class="line">            <span class="keyword">if</span> (d == <span class="number">1</span>) t[p].sum[t[p].siz % <span class="number">4</span>] += x;</span><br><span class="line">            <span class="keyword">else</span>  t[p].sum[(t[p].siz - <span class="number">1</span>) % <span class="number">4</span>] -= x;</span><br><span class="line">            t[p].siz += d;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(x, d, lson);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; mid)  <span class="built_in">modify</span>(x, d, rson);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span>&amp; p = rt)</span> </span>&#123;</span><br><span class="line">        ll sum1 = t[ls].sum[<span class="number">0</span>] + t[ls].sum[<span class="number">3</span>];  <span class="comment">// 左节点 a_i-b_i&lt;0 的情形</span></span><br><span class="line">        ll sum2 = t[ls].siz &amp; <span class="number">1</span></span><br><span class="line">            ? t[rs].sum[<span class="number">1</span>] + t[rs].sum[<span class="number">3</span>]</span><br><span class="line">            : t[rs].sum[<span class="number">0</span>] + t[rs].sum[<span class="number">2</span>];      <span class="comment">// 右节点 a_i-b_i&gt;0 的情形 需分两种情况讨论</span></span><br><span class="line">        <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> SMT::L, SMT::R, SMT::rt;</span><br><span class="line">SMT smt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">-1e5</span>, <span class="number">1e5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    ll sum0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>(), b[i] = <span class="built_in">read</span>();</span><br><span class="line">        sum0 += b[i];</span><br><span class="line">        smt.<span class="built_in">modify</span>(a[i] - b[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum0 + smt.<span class="built_in">query</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">read</span>();</span><br><span class="line">        sum0 -= b[p], smt.<span class="built_in">modify</span>(a[p] - b[p], <span class="number">-1</span>);</span><br><span class="line">        a[p] = <span class="built_in">read</span>(), b[p] = <span class="built_in">read</span>();</span><br><span class="line">        sum0 += b[p], smt.<span class="built_in">modify</span>(a[p] - b[p], <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum0 + smt.<span class="built_in">query</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例 2</strong> <a target="_blank" rel="noopener" href="https://codeforces.com/gym/104869/problem/K">2023 ICPC 沈阳 K. Maximum Rating</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mark</span> &#123;</span><br><span class="line">    <span class="type">int</span> add&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; self)</span>&amp; </span>&#123;</span><br><span class="line">        add += p.add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    ll sum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> cnt&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> mark&amp; self)</span>&amp; </span>&#123;</span><br><span class="line">        sum += p.add * L;</span><br><span class="line">        cnt += p.add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> info&amp; p)</span>&amp; </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> info <span class="keyword">operator</span> + (<span class="type">const</span> info&amp; l, <span class="type">const</span> info&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; l.sum + r.sum, l.cnt + r.cnt &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    ll sum = <span class="number">0</span>;   <span class="comment">// 负数之和</span></span><br><span class="line">    SMT&lt;info, mark&gt; smt;</span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">1</span>, inf + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> modify = [&amp;](<span class="type">int</span> val, <span class="type">int</span> d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; <span class="number">0</span>) sum += val * d;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; <span class="number">0</span>) smt.<span class="built_in">modify</span>(val, val + <span class="number">1</span>, &#123; d &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">modify</span>(a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> p, val;</span><br><span class="line">        cin &gt;&gt; p &gt;&gt; val;</span><br><span class="line">        p--;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">modify</span>(a[p], <span class="number">-1</span>);</span><br><span class="line">        a[p] = val;</span><br><span class="line">        <span class="built_in">modify</span>(a[p], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ll need = -sum;</span><br><span class="line">        p = smt.<span class="built_in">findL</span>([&amp;](<span class="type">const</span> info&amp; p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.sum &lt;= need) &#123;</span><br><span class="line">                need -= p.sum;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        res += smt.<span class="built_in">query</span>(<span class="number">0</span>, p).cnt;</span><br><span class="line">        res += <span class="built_in">min</span>(smt.<span class="built_in">query</span>(p, p + <span class="number">1</span>).cnt, <span class="built_in">int</span>(need / p));  <span class="comment">// WA: need - smt.query(0, p).sum 因为在二分中已经减去了</span></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h2 id="SMT-5- 线段树合并">SMT.5 线段树合并</h2><p>维护 <strong>从若干子结构合并成大结构</strong> 的合并过程中所有出现过的结构的完整信息，如 <strong>并查集</strong> 、树上每个节点的 <strong>子树信息</strong> 等。时空复杂度与开的总点数相同，为线性对数。</p><p>动态开点，<code>rt[p]</code> 表示节点 $p$ 所在树的根节点 unix。递归地将两棵线段树的节点信息对应合并：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将树上节点 x,y 合并到节点 z</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x | y;                  <span class="comment">// 一方为空 递归到叶 返回非空的那个节点</span></span><br><span class="line">    <span class="type">int</span> z = ++pcnt;</span><br><span class="line">    <span class="keyword">if</span> (cl == cr) <span class="keyword">return</span> <span class="comment">/* 合并叶子节点 x,y 将 y 的信息传递给 x */</span>, z;</span><br><span class="line">    <span class="built_in">push_down</span>(x), <span class="built_in">push_down</span>(y);</span><br><span class="line">    tr[z].ls = <span class="built_in">merge</span>(tr[x].ls, tr[y].ls, cl, mid);      <span class="comment">// x 的左节点和 y 的左节点合并为 z 的左节点 </span></span><br><span class="line">    tr[z].rs = <span class="built_in">merge</span>(tr[x].rs, tr[y].rs, mid + <span class="number">1</span>, cr);  <span class="comment">// x 的右节点和 y 的右节点合并为 z 的右节点 </span></span><br><span class="line">    <span class="built_in">push_up</span>(z);                                               <span class="comment">// 更新当前节点信息</span></span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    L = <span class="number">1</span>, R = n, pcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        rt[i] = ++pcnt;          <span class="comment">// 建立根节点</span></span><br><span class="line">        <span class="built_in">modify</span>(num, <span class="number">1</span>, rt[i]);   <span class="comment">// 将 num 插入权值线段树 i 指定树的根是 rt[i]</span></span><br><span class="line">    &#125;  <span class="comment">// 建 n 颗权值线段树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q = <span class="built_in">read</span>(); q--;) &#123;</span><br><span class="line">        rt[x] = rt[y] = <span class="built_in">merge</span>(rt[x], rt[y]);     <span class="comment">// 从树根开始合并 x,y 并将 x 和 y 的根设置为新根</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法保留原来两棵线段树的信息，创建了一棵新树，因此需要额外的一倍空间。如果不要求保留原来的信息，优先选择直接把第二棵树的信息加到第一棵树上，这不需要新建节点，但会毁掉原先的两棵树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将树上节点 x,y 合并到节点 x</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x | y;      <span class="comment">// 一方为空 递归到叶 返回非空的那个节点</span></span><br><span class="line">    <span class="keyword">if</span> (cl == cr) <span class="keyword">return</span> <span class="comment">/* 合并叶子节点 x,y 将 y 的信息传递给 x */</span>, x;</span><br><span class="line">    <span class="built_in">push_down</span>(x), <span class="built_in">push_down</span>(y);</span><br><span class="line">    tr[x].ls = <span class="built_in">merge</span>(tr[x].ls, tr[y].ls, cl, mid);      <span class="comment">// x 的左节点和 y 的左节点合并为 x 的左节点 </span></span><br><span class="line">    tr[x].rs = <span class="built_in">merge</span>(tr[x].rs, tr[y].rs, mid + <span class="number">1</span>, cr);  <span class="comment">// x 的右节点和 y 的右节点合并为 x 的右节点 </span></span><br><span class="line">    <span class="built_in">push_up</span>(x);                                               <span class="comment">// 更新当前节点信息</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可以把自己和自己合并！</p><div style="page-break-after:always"></div><h3 id="SMT5-1- 区间加，区间积，区间删除，并查集维护连通性">SMT5.1 区间加，区间积，区间删除，并查集维护连通性</h3><p><strong>题意</strong> 请用某种数据结构维护一个图，您的代码应当能够实现：（以下节点 $a$ 指节点编号为 $a$ 的节点）</p><ol><li>新建一个节点，权值为 $a$，若当前有 $n$ 个节点，则节点编号为 $n+1$；</li><li>连接两个节点 $a,b$；</li><li>将一个节点 $a$ 所属于的联通块内权值小于 $b$ 的所有节点权值变成 $b$；</li><li>将一个节点 $a$ 所属于的联通块内权值大于 $b$ 的所有节点权值变成 $b$；</li><li>询问一个节点 $a$ 所属于的联通块内的第 $b$ 小的权值是多少；</li><li>询问一个节点 $a$ 所属联通块内所有节点权值之积与另一个节点 $b$ 所属联通块内所有节点权值之积的大小，若 $a$ 所属联通块内所有节点权值之积大于 $b$ 所属联通块内所有节点权值之积，输出 $1$，否则为 $0$；</li><li>询问 $a$ 所在联通块内节点的数量。</li></ol><p>数据范围：$0\leqslant q\leqslant 400000, \quad 1\leqslant\mathrm{opt}\leqslant7, \quad 0\leqslant a,b\leqslant 10^9$。(VJsum1D - <a target="_blank" rel="noopener" href="https://vjudge.net.cn/problem/BZOJ-4399/origin">BZOJ4399. 魔法少女 LJJ</a>)</p><p><strong>思路</strong> 用并查集维护连通性。为了查询每个连通块里的第 $k$ 大，自然想到权值线段树，每个联通块都需要维护一个权值线段树。在并查集合并联通块的同时合并线段树。具体地，</p><ul><li>操作 1, 2, 7 是基础写法。</li><li>操作 3, 4：以 3 为例，把大于 $b$ 的变成 $b$ 等价于把大于 $b$ 的都删除，即区间赋值，再插入这么多个 $b$，即权值线段树的插入，为了知道需要插入多少个，需先查询这段区间数的数量 <code>siz</code>。</li><li>操作 5：权值线段树的 <code>kthnum</code> 模板函数。</li><li>操作 6：需维护区间积，显然这个积会爆 LL，稍作转换，维护区间 $\log$ 和。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SMT</span> &#123;</span><br><span class="line">    <span class="type">int</span> pcnt;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> L, R;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">        <span class="type">int</span> siz;</span><br><span class="line">        <span class="type">int</span> mrk;    <span class="comment">// 是否删除</span></span><br><span class="line">        <span class="type">double</span> mul;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">    &#125; t[N &lt;&lt; <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        pcnt = <span class="number">0</span>;</span><br><span class="line">        L = l, R = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        t[p] = &#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls t[p].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs t[p].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((cl+cr)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len (cr-cl+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls,cl,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs,mid+1,cr</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(info&amp; p, info l, info r)</span> </span>&#123;</span><br><span class="line">        p.siz = l.siz + r.siz;</span><br><span class="line">        p.mul = l.mul + r.mul;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(info&amp; p, <span class="type">int</span> d, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">        p.siz = d, p.mul = d * <span class="built_in">log2</span>(l);</span><br><span class="line">        p.mrk = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span>&amp; p)</span> </span>&#123; <span class="built_in">push_up</span>(t[p], t[ls], t[rs]); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[p].mrk == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">push_down</span>(t[ls], t[p].mrk, l - (l &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">push_down</span>(t[rs], t[p].mrk, l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        t[p].mrk = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d, <span class="type">int</span>&amp; p, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) p = ++pcnt, <span class="built_in">init</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (cl == cr) <span class="keyword">return</span> t[p].siz += d, t[p].mul += d * <span class="built_in">log2</span>(x), <span class="built_in">void</span>();</span><br><span class="line">        <span class="built_in">push_down</span>(p, len);</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(x, d, lson);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(x, d, rson);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>&amp; p, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> <span class="built_in">push_down</span>(t[p], <span class="number">0</span>, len);</span><br><span class="line">        <span class="built_in">push_down</span>(p, len);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">clear</span>(l, r, lson);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r)  <span class="built_in">clear</span>(l, r, rson);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>&amp; p, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> t[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, len);</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(l, r, lson);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; l)  <span class="keyword">return</span> <span class="built_in">query</span>(l, r, rson);</span><br><span class="line">        info res;</span><br><span class="line">        <span class="built_in">push_up</span>(res, <span class="built_in">query</span>(l, r, lson), <span class="built_in">query</span>(l, r, rson));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthnum</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>&amp; p, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cl == cr) <span class="keyword">return</span> cl;</span><br><span class="line">        <span class="built_in">push_down</span>(p, len);</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= t[ls].siz) <span class="keyword">return</span> <span class="built_in">kthnum</span>(k, lson);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kthnum</span>(k - t[ls].siz, rson);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> q, <span class="type">int</span> p, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q || !p) <span class="keyword">return</span> q | p;</span><br><span class="line">        <span class="keyword">if</span> (cl == cr) <span class="keyword">return</span> <span class="built_in">push_up</span>(t[q], t[q], t[p]), q;</span><br><span class="line">        <span class="built_in">push_down</span>(q, len), <span class="built_in">push_down</span>(p, len);</span><br><span class="line">        t[q].l = <span class="built_in">merge</span>(t[q].l, lson);</span><br><span class="line">        t[q].r = <span class="built_in">merge</span>(t[q].r, rson);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(q), q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> SMT::L, SMT::R;</span><br><span class="line">SMT smt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p, siz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        p.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">iota</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != p[x]) x = p[x] = p[p[x]]; <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">uno</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">same</span>(x, y)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        p[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q = <span class="built_in">read</span>(), n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSU <span class="title">dsu</span><span class="params">(q)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> L = <span class="number">1</span>, R = <span class="number">1e9</span>;</span><br><span class="line">    smt.<span class="built_in">init</span>(L, R);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> op = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;  <span class="comment">// 新建</span></span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">read</span>();</span><br><span class="line">            smt.<span class="built_in">modify</span>(a, <span class="number">1</span>, rt[++n]);  <span class="comment">// 将 1 个 a 插入新节点的权值线段树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;  <span class="comment">// 连接</span></span><br><span class="line">            <span class="type">int</span> a = dsu.<span class="built_in">find</span>(<span class="built_in">read</span>()), b = dsu.<span class="built_in">find</span>(<span class="built_in">read</span>());</span><br><span class="line">            <span class="keyword">if</span> (a == b) <span class="keyword">continue</span>;  <span class="comment">// 不能合并自己</span></span><br><span class="line">            rt[a] = rt[b] = smt.<span class="built_in">merge</span>(rt[a], rt[b]);</span><br><span class="line">            dsu.<span class="built_in">uno</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;  <span class="comment">// 把小于 b 的变成 b</span></span><br><span class="line">            <span class="type">int</span> a = dsu.<span class="built_in">find</span>(<span class="built_in">read</span>()), b = <span class="built_in">read</span>();</span><br><span class="line">            <span class="type">int</span> num = smt.<span class="built_in">query</span>(L, b, rt[a]).siz;  <span class="comment">// 需要删除 L~b 所有的数 共 num 个</span></span><br><span class="line">            smt.<span class="built_in">clear</span>(L, b, rt[a]);                <span class="comment">// 删除 L~b</span></span><br><span class="line">            smt.<span class="built_in">modify</span>(b, num, rt[a]);             <span class="comment">// 将 num 个 b 插入权值线段树 n</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;  <span class="comment">// 把大于 b 的变成 b</span></span><br><span class="line">            <span class="type">int</span> a = dsu.<span class="built_in">find</span>(<span class="built_in">read</span>()), b = <span class="built_in">read</span>();</span><br><span class="line">            <span class="type">int</span> num = smt.<span class="built_in">query</span>(b, R, rt[a]).siz;</span><br><span class="line">            smt.<span class="built_in">clear</span>(b, R, rt[a]);</span><br><span class="line">            smt.<span class="built_in">modify</span>(b, num, rt[a]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) &#123;  <span class="comment">// 求 a 的第 b 小</span></span><br><span class="line">            <span class="type">int</span> a = dsu.<span class="built_in">find</span>(<span class="built_in">read</span>()), b = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, smt.<span class="built_in">kthnum</span>(b, rt[a]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>) &#123;  <span class="comment">// 比较 a 和 b 的乘积的大小</span></span><br><span class="line">            <span class="type">int</span> a = dsu.<span class="built_in">find</span>(<span class="built_in">read</span>()), b = dsu.<span class="built_in">find</span>(<span class="built_in">read</span>());</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, smt.<span class="built_in">query</span>(L, R, rt[a]).mul &gt; smt.<span class="built_in">query</span>(L, R, rt[b]).mul);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">7</span>) &#123;  <span class="comment">// 求 a 的 siz</span></span><br><span class="line">            <span class="type">int</span> a = dsu.<span class="built_in">find</span>(<span class="built_in">read</span>());</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, smt.<span class="built_in">query</span>(L, R, rt[a]).siz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h2 id="SMT-6- 线段树上树">SMT.6 线段树上树</h2><p>[[…/ 图论 - 树 / 树 05 - 树的重链剖分、树上启发式合并 | 树 05 - 树的重链剖分、树上启发式合并]]<br>[[…/ 图论 - 树 / 树 06 - 树与线段树合并 | 树 06 - 树与线段树合并]]</p><h2 id="SMT-7- 线段树优化建图">SMT.7 线段树优化建图</h2><p>[[…/ 图论 / 图论技巧集 #转化为线段树——区间连边 | 图论习题集]]</p><h2 id="SMT-8- 线段树与扫描线">SMT.8 线段树与扫描线</h2><p>求所有 $W\times H$ 格点矩形区域（不含边框）内，点权之和最大值。(<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1502">VJsum7F - 窗口的星星</a>)</p><p>将点 $(x,y)$ 扩展为 $(x+W-1,y+H-1)$ 的矩形，矩形重叠则点权相加，即是求平面内权值最大的区域。类似于扫描线，但是求区间最大值，而不是区间不同数的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// ---------------- 扫描线 ----------------</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RECT</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y1, y2, op;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> RECT&amp; yall) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == yall.x ? op &gt; yall.op : x &lt; yall.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;RECT&gt; rect;  <span class="comment">// &#123;x, y1, y2, op&#125;</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; yall;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2, <span class="type">int</span> y1, <span class="type">int</span> y2, <span class="type">int</span> d = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    yall.<span class="built_in">push_back</span>(y1);</span><br><span class="line">    yall.<span class="built_in">push_back</span>(y2);</span><br><span class="line">    rect.<span class="built_in">push_back</span>(&#123; x1, y1, y2, d &#125;);</span><br><span class="line">    rect.<span class="built_in">push_back</span>(&#123; x2, y1, y2, -d &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ---------------- 线段树 ----------------</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SMT</span> &#123;</span><br><span class="line">    <span class="type">int</span> pcnt;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> L, R, rt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">        ll mx, mrk;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">    &#125; t[N &lt;&lt; <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        pcnt = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line">        L = l, R = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        t[p] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls t[p].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs t[p].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((cl+cr)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len (cr-cl+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls,cl,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs,mid+1,cr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这两个函数中写需要维护的东西 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(info&amp; p, info l, info r)</span> </span>&#123;</span><br><span class="line">        p.mx = <span class="built_in">max</span>(l.mx, r.mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(info&amp; p, ll d, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">        p.mx += d;</span><br><span class="line">        p.mrk += d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下传与回溯</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span>&amp; p)</span> </span>&#123; <span class="built_in">push_up</span>(t[p], t[ls], t[rs]); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ls) ls = ++pcnt, <span class="built_in">init</span>(ls);</span><br><span class="line">        <span class="built_in">push_down</span>(t[ls], t[p].mrk, l - (l &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (!rs) rs = ++pcnt, <span class="built_in">init</span>(rs);</span><br><span class="line">        <span class="built_in">push_down</span>(t[rs], t[p].mrk, l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        t[p].mrk = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间[l,r] 加 d</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll d, <span class="type">int</span>&amp; p = rt, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) p = ++pcnt, <span class="built_in">init</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> <span class="built_in">push_down</span>(t[p], d, len);</span><br><span class="line">        <span class="built_in">push_down</span>(p, len);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(l, r, d, lson);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r)  <span class="built_in">modify</span>(l, r, d, rson);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询[l,r]</span></span><br><span class="line">    <span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>&amp; p = rt, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> t[p];</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(l, r, lson);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; l)  <span class="keyword">return</span> <span class="built_in">query</span>(l, r, rson);</span><br><span class="line">        info res;</span><br><span class="line">        <span class="built_in">push_up</span>(res, <span class="built_in">query</span>(l, r, lson), <span class="built_in">query</span>(l, r, rson));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> SMT::L, SMT::R, SMT::rt;</span><br><span class="line">SMT smt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ---------------- 主函数 ----------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), W = <span class="built_in">read</span>(), H = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">-1e9</span>, <span class="number">1e9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), d = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(x, x + W - <span class="number">1</span>, y, y + H - <span class="number">1</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(rect.<span class="built_in">begin</span>(), rect.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(yall.<span class="built_in">begin</span>(), yall.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y1, y2, op] : rect) &#123;</span><br><span class="line">        y1 = <span class="built_in">lower_bound</span>(yall.<span class="built_in">begin</span>(), yall.<span class="built_in">end</span>(), y1) - yall.<span class="built_in">begin</span>();</span><br><span class="line">        y2 = <span class="built_in">lower_bound</span>(yall.<span class="built_in">begin</span>(), yall.<span class="built_in">end</span>(), y2) - yall.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, smt.<span class="built_in">query</span>(<span class="number">-1e9</span>, <span class="number">1e9</span>).mx);</span><br><span class="line">        smt.<span class="built_in">modify</span>(y1, y2, op);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    rect.<span class="built_in">clear</span>();</span><br><span class="line">    yall.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h3 id="SMT8-1- 区间加，区间数的种类（标记永久化／拖拖）">SMT8.1 区间加，区间数的种类（标记永久化／拖拖）</h3><p>拖拖是一个扫地机器猫。给定一个由 $n$ 个移动操作组成的序列，第 $i$ 个移动操作由方向 $d_i$ 和距离 $a_i$ 组成。根据给定的拖拖移动操作，计算清扫的总面积。<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P10096">洛谷 10096</a></p><p>数据范围：$1 \leqslant k \leqslant 10^4$，$1 \leqslant n \leqslant 10^5$，$1 \leqslant a_i \leqslant 10^9$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// ---------------- 扫描线 ----------------</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RECT</span> &#123;</span><br><span class="line">    ll x, y1, y2;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> RECT&amp; yall) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == yall.x ? op &gt; yall.op : x &lt; yall.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;RECT&gt; rect;  <span class="comment">// &#123;x, y1, y2, op&#125;</span></span><br><span class="line">vector&lt;ll&gt; yall;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll x1, ll x2, ll y1, ll y2, <span class="type">int</span> d = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    yall.<span class="built_in">push_back</span>(y1);</span><br><span class="line">    yall.<span class="built_in">push_back</span>(y2);</span><br><span class="line">    rect.<span class="built_in">push_back</span>(&#123; x1, y1, y2, d &#125;);</span><br><span class="line">    rect.<span class="built_in">push_back</span>(&#123; x2, y1, y2, -d &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ---------------- 线段树 ----------------</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SMT</span> &#123;</span><br><span class="line">    <span class="type">int</span> pcnt;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> L, R, rt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">        ll typ, mrk;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">    &#125; t[N &lt;&lt; <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        pcnt = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line">        L = l, R = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        t[p] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls t[p].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs t[p].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((cl+cr)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len (cr-cl+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls,cl,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs,mid+1,cr</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> cl, <span class="type">int</span> cr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[p].mrk) t[p].typ = yall[cr + <span class="number">1</span>] - yall[cl]; <span class="comment">// 标记永久化 yall 是离散化后的数组</span></span><br><span class="line">        <span class="keyword">else</span> t[p].typ = t[ls].typ + t[rs].typ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d, <span class="type">int</span>&amp; p = rt, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) p = ++pcnt;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> t[p].mrk += d, <span class="built_in">push_up</span>(p, cl, cr);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(l, r, d, lson);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r)  <span class="built_in">modify</span>(l, r, d, rson);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">push_up</span>(p, cl, cr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l = L, <span class="type">int</span> r = R, <span class="type">int</span>&amp; p = rt, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> t[p].typ;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(l, r, lson);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; l)  <span class="keyword">return</span> <span class="built_in">query</span>(l, r, rson);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l, r, lson) + <span class="built_in">query</span>(l, r, rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> SMT::L, SMT::R, SMT::rt;</span><br><span class="line">SMT smt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">read</span>(), n = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">0</span>, <span class="number">2</span> * n);</span><br><span class="line"></span><br><span class="line">    ll x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> op; <span class="keyword">do</span> op = <span class="built_in">getchar</span>(); <span class="keyword">while</span> (op != <span class="string">&#x27;N&#x27;</span> &amp;&amp; op != <span class="string">&#x27;S&#x27;</span> &amp;&amp; op != <span class="string">&#x27;E&#x27;</span> &amp;&amp; op != <span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;N&#x27;</span>) <span class="built_in">add</span>(x, x + k, y, y + k + d), y += d;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;S&#x27;</span>) <span class="built_in">add</span>(x, x + k, y - d, y + k), y -= d;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;E&#x27;</span>) <span class="built_in">add</span>(x, x + k + d, y, y + k), x += d;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;W&#x27;</span>) <span class="built_in">add</span>(x - d, x + k, y, y + k), x -= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(rect.<span class="built_in">begin</span>(), rect.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(yall.<span class="built_in">begin</span>(), yall.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>, lst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y1, y2, op] : rect) &#123;</span><br><span class="line">        y1 = <span class="built_in">lower_bound</span>(yall.<span class="built_in">begin</span>(), yall.<span class="built_in">end</span>(), y1) - yall.<span class="built_in">begin</span>();</span><br><span class="line">        y2 = <span class="built_in">lower_bound</span>(yall.<span class="built_in">begin</span>(), yall.<span class="built_in">end</span>(), y2) - yall.<span class="built_in">begin</span>();</span><br><span class="line">        res += (x - lst) * smt.<span class="built_in">query</span>();</span><br><span class="line">        lst = x;</span><br><span class="line"></span><br><span class="line">        smt.<span class="built_in">modify</span>(y1, y2 - <span class="number">1</span>, op);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SMT9- 可持久化线段树">SMT9. 可持久化线段树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rt[N];</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="type">int</span> L, R, pcnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SMT</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">        ll sum, mrk;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">    &#125; t[N &lt;&lt; <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        pcnt = <span class="number">0</span>;</span><br><span class="line">        L = l, R = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        t[p] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls t[p].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs t[p].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((cl+cr)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len (min(cr,r)-max(cl,l)+1)  <span class="comment">// 不同于普通线段树的(cr-cl+1)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls,cl,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs,mid+1,cr</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>&amp; p, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        p = ++pcnt, <span class="built_in">init</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (cl == cr) <span class="keyword">return</span> t[p].sum = a[cl], <span class="built_in">void</span>();</span><br><span class="line">        <span class="built_in">build</span>(lson), <span class="built_in">build</span>(rson);</span><br><span class="line">        t[p].sum = t[ls].sum + t[rs].sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll d, <span class="type">int</span> q, <span class="type">int</span>&amp; p, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        t[p = ++pcnt] = t[q];   <span class="comment">// 持久化须新建节点</span></span><br><span class="line">        t[p].sum += d * len;    <span class="comment">// 没有 push_up 直接修改 sum</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> t[p].mrk += d, <span class="built_in">void</span>();</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(l, r, d, t[q].l, lson);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r)  <span class="built_in">modify</span>(l, r, d, t[q].r, rson);</span><br><span class="line">        <span class="keyword">return</span>;    <span class="comment">// 标记永久化不能 push_up(p)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>&amp; p, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">        ll res = t[p].mrk * len;   <span class="comment">// 永久标记直接加上</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) res += <span class="built_in">query</span>(l, r, lson);</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; r)  res += <span class="built_in">query</span>(l, r, rson);</span><br><span class="line">        <span class="keyword">return</span> res;   <span class="comment">// 这里采用了老式写法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>&amp; q, <span class="type">int</span>&amp; p, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cl &gt;= cr) <span class="keyword">return</span> cl;</span><br><span class="line">        <span class="type">int</span> s = t[t[p].l].sum - t[t[q].l].sum;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= s) <span class="keyword">return</span> <span class="built_in">kth</span>(k, t[q].l, lson);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(k - s, t[q].r, rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; smt;</span><br></pre></td></tr></table></figure><h3 id="SMT9-0- 静态区间第 -k- 小">SMT9.0 静态区间第 k 小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">1</span>, <span class="number">2e5</span>);</span><br><span class="line">    smt.<span class="built_in">build</span>(rt[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">        smt.<span class="built_in">modify</span>(x, x, <span class="number">1</span>, rt[i - <span class="number">1</span>], rt[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q = <span class="built_in">read</span>(); q--;) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> ans = smt.<span class="built_in">kth</span>(k, rt[l - <span class="number">1</span>], rt[r]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SMT9-1- 历史版本区间加，区间和">SMT9.1 历史版本区间加，区间和</h3><p><a target="_blank" rel="noopener" href="https://vjudge.net/problem/SPOJ-TTM">To the moon</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    smt.<span class="built_in">init</span>(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    smt.<span class="built_in">build</span>(rt[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">char</span> op = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;C&#x27;</span>) &#123; <span class="comment">// 区间修改 </span></span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), d = <span class="built_in">read</span>();</span><br><span class="line">            ++now;</span><br><span class="line">            smt.<span class="built_in">modify</span>(l, r, d, rt[now - <span class="number">1</span>], rt[now]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;Q&#x27;</span>) &#123; <span class="comment">// 查询当前版本 </span></span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, smt.<span class="built_in">query</span>(l, r, rt[now]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>) &#123; <span class="comment">// 查询历史版本</span></span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), old = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, smt.<span class="built_in">query</span>(l, r, rt[old]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;B&#x27;</span>) &#123; <span class="comment">// 版本回溯</span></span><br><span class="line">            now = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SMT9-2- 历史版本区间赋值，区间加">SMT9.2 历史版本区间赋值，区间加</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll d, <span class="type">int</span> q, <span class="type">int</span>&amp; p, <span class="type">int</span> cl = L, <span class="type">int</span> cr = R)</span> </span>&#123;</span><br><span class="line">    t[p = ++pcnt] = t[q];   <span class="comment">// 持久化须新建节点</span></span><br><span class="line">    t[p].sum = d * len;     <span class="comment">// 没有 push_up 直接修改 sum</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> t[p].mrk = d, <span class="built_in">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(l, r, d, t[q].l, lson);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; r)  <span class="built_in">modify</span>(l, r, d, t[q].r, rson);</span><br><span class="line">    <span class="keyword">return</span>;    <span class="comment">// 标记永久化不能 push_up(p)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h1>凸包</h1><p>问题 (插入直线, 询问最小值 7)<br>给定 $n$ 条直线, 按顺序执行以下 $q$ 个询问:<br>$a, b$：插入直线 $y = ax + b$。<br>$p$：求最小的 $y$ 使得 $y = x \cdot p$。<br>问题可以转化为插入点 $(a, b)$, 求 $(- p, -1)$ 和其中某个点的最大点积。</p><p>假设没有插入操作:<br>答案一定是凸包上的点。分成上下两个凸包后，答案是凸的，可以通过二分得到答案。</p><p>二进制分组:<br>对于 $n$ 个点, 根据二进制表示 $n = 2^k_0 + 2^{k_1} + \cdots$, 分别维护 $2^k$ 个点形成的凸包。插入新的点时增加 1 个点形成的凸包, 类似二进制进位加法, 当存在两个 $2^k$ 个点形成凸包时, 合并成一个 $2^{k+1}$ 个点形成凸包, 直到没有相同大小的凸包。插入均摊复杂度为 $\Theta(\log n)$, 询问复杂度为 $\Theta(\log^2 n)$。GCC 实现 list.sort 时使用二进制分组。对于 AC 自动机等不能在线插入的结构可以使用二进制分组实现在线插入。</p><h1>李超线段树</h1><p>问题 (插入线段, 询问最小值 9)<br>给定 $n$ 条直线, 按顺序执行以下 $q$ 个询问:<br>$l, r, a, b$：插入线段 $y = ax + b$, 线段 x 轴区间为 $[l, r)$.<br>$p$：求最小的 $y$ 使得 $y = x \cdot p$。</p><p>使用线段树的结构, 每个结点保存一条线段, 询问结果为单点和其所有祖先线段的最小值。<br>在结点插入线段时, 和原来线段比较, 至少有一条线段在其一半的区间完全在另一条线段下方, 将这条线段保存在结点中。<br>对另一条线段, 如果在其中一半可能比另一条线段小, 则递归插入该线段。<br>离散化询问的坐标, 插入复杂度为 $\Theta(\log^2 n)$, 询问复杂度为 $\Theta(\log n)$。</p><p>其他数据结构</p><ul><li>有用的：带权并查集、Treap</li><li>没有用的：Splay 和 动态树、KD tr</li></ul><h1>分块、莫队</h1><p><strong>莫队</strong> 基于 <strong>分块</strong> ，是一种解决区间查询等问题的 <strong>离线</strong> 算法，适用于能够在 $\Theta(1)$ 内将答案从 $[l,r]$ 转移到 $[l-1,r]$、$[l+1,r]$、$[l,r-1]$、$[l,r+1]$ 这四个与之紧邻的区间的答案的问题。时间复杂度 $\Theta(n\sqrt{ n})$。</p><p>只需修改 <code>add()</code> 和 <code>del()</code> 函数。</p><p><strong>例</strong> 询问区间颜色个数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        arr[i] = <span class="built_in">read</span>();</span><br><span class="line">        alls.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        arr[i] = <span class="built_in">lower_bound</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>(), arr[i]) - alls.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> B = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QUE</span> &#123;</span><br><span class="line">        <span class="type">int</span> ql, qr, id;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> QUE&amp; b) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ql / B != b.ql / B ? ql &lt; b.ql : (ql / B &amp; <span class="number">1</span> ? qr &lt; b.qr : qr &gt; b.qr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="function">vector&lt;QUE&gt; <span class="title">que</span><span class="params">(q)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        que[i].ql = <span class="built_in">read</span>(), que[i].qr = <span class="built_in">read</span>();</span><br><span class="line">        que[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[arr[p]] == <span class="number">0</span>) now++;</span><br><span class="line">        cnt[arr[p]]++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> del = [&amp;](<span class="type">int</span> p) &#123;</span><br><span class="line">        cnt[arr[p]]--;</span><br><span class="line">        <span class="keyword">if</span> (cnt[arr[p]] == <span class="number">0</span>) now--;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cl = <span class="number">1</span>, cr = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(q)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [ql, qr, id] : que) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cl &gt; ql) <span class="built_in">add</span>(--cl);</span><br><span class="line">        <span class="keyword">while</span> (cr &lt; qr) <span class="built_in">add</span>(++cr);</span><br><span class="line">        <span class="keyword">while</span> (cl &lt; ql) <span class="built_in">del</span>(cl++);</span><br><span class="line">        <span class="keyword">while</span> (cr &gt; qr) <span class="built_in">del</span>(cr--);</span><br><span class="line">        res[id] = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例</strong> 询问区间每种元素出现次数的平方和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> p) &#123;</span><br><span class="line">    now -= cnt[arr[p]] * cnt[arr[p]];</span><br><span class="line">    cnt[arr[p]]++;</span><br><span class="line">    now += cnt[arr[p]] * cnt[arr[p]];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> del = [&amp;](<span class="type">int</span> p) &#123;</span><br><span class="line">    now -= cnt[arr[p]] * cnt[arr[p]];</span><br><span class="line">    cnt[arr[p]]--;</span><br><span class="line">    now += cnt[arr[p]] * cnt[arr[p]];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三维莫队">三维莫队</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QUE</span> &#123;</span><br><span class="line">    <span class="type">int</span> ql, qr, qt, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> QUE&amp; b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ql / B == b.ql / B ? (qr / B == b.qr / B ? qt &lt; b.qt : qr &lt; b.qr) : ql &lt; b.ql;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; que[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UPD</span> &#123;</span><br><span class="line">    <span class="type">int</span> pos, c;</span><br><span class="line">&#125; upd[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res, arr[N], ans[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[x] == <span class="number">0</span>) res++;</span><br><span class="line">    ++cnt[x];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    --cnt[x];</span><br><span class="line">    <span class="keyword">if</span> (cnt[x] == <span class="number">0</span>) res--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> qt)</span> </span>&#123; <span class="comment">// update() from ct to qt</span></span><br><span class="line">    <span class="comment">// upd[qt].pos in [ql, qr]</span></span><br><span class="line">    <span class="keyword">if</span> (que[x].ql &lt;= upd[qt].pos &amp;&amp; upd[qt].pos &lt;= que[x].qr) &#123;</span><br><span class="line">        <span class="built_in">del</span>(arr[upd[qt].pos]);</span><br><span class="line">        <span class="built_in">add</span>(upd[qt].c);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(arr[upd[qt].pos], upd[qt].c);  <span class="comment">// change the color</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eachT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    B = <span class="built_in">pow</span>(n, <span class="number">0.666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        arr[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cntq = <span class="number">0</span>, cntr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        std::string op;</span><br><span class="line">        std::cin &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            ++cntq;</span><br><span class="line">            que[cntq].ql = <span class="built_in">read</span>();</span><br><span class="line">            que[cntq].qr = <span class="built_in">read</span>();</span><br><span class="line">            que[cntq].qt = cntr;</span><br><span class="line">            que[cntq].id = cntq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++cntr;</span><br><span class="line">            upd[cntr].pos = <span class="built_in">read</span>();</span><br><span class="line">            upd[cntr].c = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(que + <span class="number">1</span>, que + cntq + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cl = <span class="number">1</span>, cr = <span class="number">0</span>, ct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [ql, qr, qt, id] = que[i];</span><br><span class="line">        <span class="keyword">while</span> (cl &gt; ql) <span class="built_in">add</span>(arr[--cl]);</span><br><span class="line">        <span class="keyword">while</span> (cl &lt; ql) <span class="built_in">del</span>(arr[cl++]);</span><br><span class="line">        <span class="keyword">while</span> (cr &gt; qr) <span class="built_in">del</span>(arr[cr--]);</span><br><span class="line">        <span class="keyword">while</span> (cr &lt; qr) <span class="built_in">add</span>(arr[++cr]);</span><br><span class="line">        <span class="keyword">while</span> (ct &lt; qt) <span class="built_in">update</span>(i, ++ct);</span><br><span class="line">        <span class="keyword">while</span> (ct &gt; qt) <span class="built_in">update</span>(i, ct--);</span><br><span class="line">        ans[id] = res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间直线加, 区间最小值<br>问题 (区间直线加, 区间最小值 13)<br>给定长度为 $n$ 的整数序列 $a_0, a_1, …, a_{n-1}$, 执行以下 $q$ 个询问:<br>$l, r, b, c$：对 $i \in [l, r)$, $a_i$ 修改为 $a_i + b \cdot i + c$。<br>$l, r$：输出 $\min(a_l, a_{l+1}, …, a_{r-1})$。</p><p>May Holidays<br>问题 (May Holidays 14)<br>给定大小为 $n$ 的树, 第 $i$ 个点有权值 $t_i$, 初始时没有离开, 执行 $q$ 个询问:<br>$i$：若 $i$ 离开, 则 $i$ 回来; 否则离开。回答有多少个点 $i$ 没有离开, 但后代中有超过 $t_i$ 个点离开。</p><p>Manhattan 旅行商问题<br>问题 (Manhattan 旅行商问题)<br>给定平面值域为 $[0, n]$ 的 $q$ 个整点 $(l_i, r_i)$, 求 $0, 1, …, q-1$ 的排列 $p$, 使得 $\sum_{i=1}^{q-1} |l_{p_{i-1}} - l_{p_i}| + |r_{p_{i-1}} - r_{p_i}|$ 尽可能小。<br>我们总有 $\Theta(n\sqrt{q})$ 的解, 只需要将点按 $(\lfloor l_i / B \rfloor, r_i)$ 排序。对于 $\lfloor l_i / B \rfloor$ 相同的相邻点, 两个维度的总移动距离分别为 $\Theta(qB)$ 和 $\Theta(n^2 / B)$。对于 $\lfloor l_i / B \rfloor$ 不同的相邻点, 总移动距离为 $\Theta(n^2 / B)$。取 $B = n^{2/3} q^{-1/3}$ 即可。</p><p>静态区间不同值个数<br>问题 (静态区间不同值个数 15)<br>给定长度为 $n$ 的整数序列 $a_0, a_1, …, a_{n-1}$, 执行以下 $q$ 个询问:<br>$l, r$：输出 $a_l, a_{l+1}, …, a_{r-1}$ 中不同值个数。</p><p>树上路径不同值个数<br>问题 (树上路径不同值个数 16)<br>给定 $n$ 个结点的树, 每个结点有值 $a_i$, 执行以下 $q$ 个询问:<br>$u, v$：输出 $a_{p_0}, a_{p_1}, …, a_{p_k}$ 中不同值个数, 其中 $p_0 = u, p_1, …, p_k = v$ 是树上简单路径。</p><p>单点修改, 区间不同值个数<br>问题 (静态区间不同值个数 17)<br>给定长度为 $n$ 的整数序列 $a_0, a_1, …, a_{n-1}$, 执行以下 $q$ 个询问:<br>$p, x$：将 $a_p$ 修改为 $x$。<br>$l, r$：输出 $a_l, a_{l+1}, …, a_{r-1}$ 中不同值个数。</p><p>静态区间众数<br>问题 (静态区间众数 18)<br>给定长度为 $n$ 的整数序列 $a_0, a_1, …, a_{n-1}$, 执行以下 $q$ 个询问:<br>$l, r$：输出 $a_l, a_{l+1}, …, a_{r-1}$ 的任意一个众数。</p><p>静态区间逆序数<br>问题 (静态区间逆序数 19)<br>给定长度为 $n$ 的整数序列 $a_0, a_1, …, a_{n-1}$, 执行以下 $q$ 个询问:<br>$l, r$：输出 $a_l, a_{l+1}, …, a_{r-1}$ 的逆序数。</p><h1>笛卡尔树</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector <span class="title">ls</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span>, <span class="title">rs</span><span class="params">(n +  <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// stk 维护笛卡尔树中节点对应到序列中的下标 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> k = top; <span class="comment">// top 表示操作前的栈顶，k 表示当前栈顶</span></span><br><span class="line">	<span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; w[stk[k]] &gt; w[i]) k--; <span class="comment">// 维护右链上的节点 </span></span><br><span class="line">	<span class="keyword">if</span> (k) rs[stk[k]] = i; <span class="comment">// 栈顶元素. 右儿子 := 当前元素 </span></span><br><span class="line">	<span class="keyword">if</span> (k &lt; top) ls[i] = stk[k + <span class="number">1</span>]; <span class="comment">// 当前元素. 左儿子 := 上一个被弹出的元素 </span></span><br><span class="line">	stk[++k] = i; <span class="comment">// 当前元素入栈 top = k; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="http://kobicgend.top">小明同學</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結:</span> <span class="post-copyright-info"><a href="http://kobicgend.top/posts/935ec80a.html">http://kobicgend.top/posts/935ec80a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明:</span> <span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="http://kobicgend.top" target="_blank">小明の雜貨屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ACM/">ACM</a><a class="post-meta__tags" href="/tags/%E7%AD%86%E8%A8%98/">筆記</a><a class="post-meta__tags" href="/tags/%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/">數據結構</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/d742f422.html" title="XCPC wiki - 质数与约数"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">XCPC wiki - 质数与约数</div></div><div class="info-2"><div class="info-item-1">![[…/data/img/e5e92bc7d32828b005d6b7f73694da57_720.jpg]] 素数筛 （欧拉筛） 1234567891011121314vector&lt;int&gt; prime;int mint[N]; // 最小素因子 void init() &#123; for (int i = 2; i &lt; N; i++) &#123; if (!mint[i]) mint[i] = i, prime.push_back(i); for (auto&amp; p : prime) &#123; if (1ll * i * p &gt;= N) break; mint[i * p] = p; if (p == mint[i]) break; &#125; &#125; mint[1] = 1;&#125; 时间复杂度 $\Theta(n)$ VJwin6D - 又见 GCD 题意 已知 $a,~b$，数...</div></div></div></a><a class="pagination-related" href="/posts/3ef02b0.html" title="XCPC wiki - 并查集 Disjoint Set Union (Uno-Find Set)"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">XCPC wiki - 并查集 Disjoint Set Union (Uno-Find Set)</div></div><div class="info-2"><div class="info-item-1">DSU01 - Find by Optimized Path Compression 路径压缩优化 12345678910111213141516171819202122232425262728struct DSU &#123; vector&lt;int&gt; p, siz; DSU(int n) : p(n + 1), siz(n + 1, 1) &#123; iota(p.begin(), p.end(), 0); &#125; int find(int x) &#123; while (x != p[x]) x = p[x] = p[p[x]]; // 路径压缩 return x; &#125; bool same(int x, int y) &#123; return find(x) == find(y); &#125; bool uno(int x, int y) &#123; x = find(x), y =...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/366bb2f2.html" title="【组合计数杂谈】三道 Bingo 游戏题（备份）"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-01</div><div class="info-item-2">【组合计数杂谈】三道 Bingo 游戏题（备份）</div></div><div class="info-2"><div class="info-item-1">本文涉及的知识点：组合数公式，古典概型，Min-Max 反演及推广，卷积优化思想，状态压缩思想与状态压缩 DP，快速数论变换 NTT，快速数论变换 NTT，快速沃尔什变换 FWT。 本系列教程「以题带讲」，以典型题目为载体，着重讲解知识点的适用条件和使用方法，而规避复杂的理论推导。 我不擅长数学，对 CF 和区域赛的数学题，从简单计算到数论组合都望而却步。「tag 是数学吗那不做了。」 可能是因为网上的教程大多是罗列定理，给出大段证明，最后放几个例题链接。我没有耐心和能力读完整篇文章。 2024 ICPC World Finals Astana B. Bingo for the Win! Bingo 游戏，$n$ 个人每人要抢 $k$ 个数，主持人按随机顺序依次报数，报到每个数 $[1,10^{9}]$ 的概率相同。已知如果有多名选手要抢某个数字，那么编号小的选手总是优先抢到。问每个人成为最后一名（其他人都抢完了但自己还没抢完）的概率。 ...</div></div></div></a><a class="pagination-related" href="/posts/ba204004.html" title="Educational Codeforces Round 173 A - E"><img class="cover" src="/img/posts/acm/codeforces-cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-21</div><div class="info-item-2">Educational Codeforces Round 173 A - E</div></div><div class="info-2"><div class="info-item-1">2043A - Coin Transformation 按题意模拟。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; ll x; cin &gt;&gt; x; ll ans = 1; while (x &gt; 3) &#123; x /= 4; ans &lt;&lt;= 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 2043B - Digits（分类） 写 $n!$ 次数字 $d$。所以，他得到了数字 $dddddd…ddd$（$n!$ 位...</div></div></div></a><a class="pagination-related" href="/posts/43a1bd89.html" title="樹上問題 - 樹形 DP"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-08</div><div class="info-item-2">樹上問題 - 樹形 DP</div></div><div class="info-2"><div class="info-item-1">Tree 1234567891011121314151617181920212223242526272829303132333435363738struct node &#123; string data; int l, r;&#125;t[10005];void pretvs(int k) &#123; // 先序遍历：先遍历根节点，然后遍历左节点，最后遍历右节点 if (k == 0)return; cout &lt;&lt; t[k].data; if (t[k].l != 0) pretvs(t[k].l); if (t[k].r != 0) pretvs(t[k].r);&#125;void intvs(int k) &#123;// 中序遍历：先遍历左节点，然后遍历根节点，最后遍历右节点（大概可以理解为把树平面投影至二维从左到右） if (k == 0)return; if (t[k].l != 0) intvs(t[k].l); cout &lt;&lt; t[k].data; if (t[k].r !=...</div></div></div></a><a class="pagination-related" href="/posts/6370b5c4.html" title="Educational Codeforces Round 175 (Rated for Div. 2) A-E"><img class="cover" src="/img/posts/acm/codeforces-cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-28</div><div class="info-item-2">Educational Codeforces Round 175 (Rated for Div. 2) A-E</div></div><div class="info-2"><div class="info-item-1">2070A. FizzBuzz Remixed 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int J; cin &gt;&gt; J; while (J--) &#123; int n; cin &gt;&gt; n; cout &lt;&lt; (n / 15 * 3 + min(n % 15, 2) + 1) &lt;&lt; endl; &#125; return 0;&#125; 2070B - Robot Program 仔细审题 题解 分为两部分考虑，从起点走到 0，从 0 下一次走到 0。 ...</div></div></div></a><a class="pagination-related" href="/posts/f9a46751.html" title="Codeforces Round 982 (Div. 2)"><img class="cover" src="/img/posts/acm/codeforces-cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-27</div><div class="info-item-2">Codeforces Round 982 (Div. 2)</div></div><div class="info-2"><div class="info-item-1">A. Rectangle Arrangement 取最大值的正确性：凸阶梯形平移后即是矩形，其周长与矩形周长相等。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; int X = 0, Y = 0; while (n--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; X = max(X, x); Y = max(Y, y); ...</div></div></div></a><a class="pagination-related" href="/posts/ec4161c0.html" title="Codeforces Round 1008 (Div. 1) A - C"><img class="cover" src="/img/posts/acm/codeforces-cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">Codeforces Round 1008 (Div. 1) A - C</div></div><div class="info-2"><div class="info-item-1">2077A/2078C - Breach of Faith 取较大的 $\cfrac{n}{2}+1$ 个放在奇数位，较小的放在偶数位。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() &#123; int J; cin &gt;&gt; J; while (J--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n * 2); for (int i = 0; i &lt; n * 2; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a.begin(), a.end()); vector&lt;ll&gt;...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>評論</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">小明同學</div><div class="author-info-description">「一直游到海水變藍。」</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">382</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kobicgend"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">用於備份小明的腦子。<br>———— <b>Tips</b> ————<br>部分評論從QQ空間或puq抓取，由於技術有限，無法顯示正確的位置和時間，望見諒。<br>———— <b>本站常規欄目</b> ————<br>周日中午:高中回憶《中外历史纲要》<br>周二清晨:語錄體《主机註記》<br>周三下午:有事大家谈/掷地有声<br>周三/六晚上:算法學習筆記<br>———— <b>計劃中</b> ————<br>美食評測, 每日一圖, ...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">ST Table</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">BIT 树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BIT-1-%20%E6%9D%83%E5%80%BC%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%20-%C3%97-%20%E4%BA%8C%E7%BB%B4%E5%81%8F%E5%BA%8F"><span class="toc-text">BIT.1 权值树状数组 × 二维偏序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text">模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-text">应用：逆序对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E4%B8%80%E8%88%AC%E7%9A%84%E6%83%85%E5%BD%A2"><span class="toc-text">更一般的情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIT-2-%20%E9%AB%98%E9%98%B6%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">BIT.2 高阶前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BIT-2-1-%20%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%92%8C%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2"><span class="toc-text">BIT.2.1 区间修改和单点查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BIT-2-2-%20%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%92%8C%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="toc-text">BIT.2.2 区间修改和区间查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BIT2-3-%20%E9%AB%98%E9%98%B6%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">BIT2.3 高阶前缀和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIT-2-%20%E5%A4%9A%E7%BB%B4%20-BIT"><span class="toc-text">BIT.2 多维 BIT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIT-3-%20%E5%90%8E%E7%BC%80%20-BIT"><span class="toc-text">BIT.3 后缀 BIT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%82%B9"><span class="toc-text">二维数点</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">SMT 线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SMT1-%20%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9"><span class="toc-text">SMT1. 单点修改</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SMT1-1-%20%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C"><span class="toc-text">SMT1.1 区间最大子段和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMT1-2-%20%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0%E5%8C%BA%E9%97%B4%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%80%BC"><span class="toc-text">SMT1.2 一次函数区间复合函数求值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMT2-%20%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E3%80%81%E6%87%92%E6%A0%87%E8%AE%B0"><span class="toc-text">SMT2. 区间修改、懒标记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SMT2-1-%20%E5%8C%BA%E9%97%B4%E4%B9%98%E3%80%81%E5%8C%BA%E9%97%B4%E5%8A%A0%EF%BC%8C%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-text">SMT2.1 区间乘、区间加，区间和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMT2-2-%20%E5%8C%BA%E9%97%B4%E5%8A%A0%EF%BC%8C%E5%8C%BA%E9%97%B4%E5%B9%B3%E6%96%B9%E5%92%8C"><span class="toc-text">SMT2.2 区间加，区间平方和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMT2-3-%20%E5%8C%BA%E9%97%B4%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-text">SMT2.3 区间赋值，区间和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMT2-4-%20%E5%8C%BA%E9%97%B4%E8%B5%8B%E5%80%BC%E3%80%81%E5%8C%BA%E9%97%B4%E5%8A%A0%EF%BC%8C%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC%E5%8F%8A%E5%85%B6%E4%B8%AA%E6%95%B0"><span class="toc-text">SMT2.4 区间赋值、区间加，区间最值及其个数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMT-3-%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BA%8C%E5%88%86"><span class="toc-text">SMT.3 线段树二分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMT-4-%20%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">SMT.4 权值线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMT-5-%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6"><span class="toc-text">SMT.5 线段树合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SMT5-1-%20%E5%8C%BA%E9%97%B4%E5%8A%A0%EF%BC%8C%E5%8C%BA%E9%97%B4%E7%A7%AF%EF%BC%8C%E5%8C%BA%E9%97%B4%E5%88%A0%E9%99%A4%EF%BC%8C%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%BB%B4%E6%8A%A4%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-text">SMT5.1 区间加，区间积，区间删除，并查集维护连通性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMT-6-%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8A%E6%A0%91"><span class="toc-text">SMT.6 线段树上树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMT-7-%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE"><span class="toc-text">SMT.7 线段树优化建图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMT-8-%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%89%AB%E6%8F%8F%E7%BA%BF"><span class="toc-text">SMT.8 线段树与扫描线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SMT8-1-%20%E5%8C%BA%E9%97%B4%E5%8A%A0%EF%BC%8C%E5%8C%BA%E9%97%B4%E6%95%B0%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B0%B8%E4%B9%85%E5%8C%96%EF%BC%8F%E6%8B%96%E6%8B%96%EF%BC%89"><span class="toc-text">SMT8.1 区间加，区间数的种类（标记永久化／拖拖）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMT9-%20%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">SMT9. 可持久化线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SMT9-0-%20%E9%9D%99%E6%80%81%E5%8C%BA%E9%97%B4%E7%AC%AC%20-k-%20%E5%B0%8F"><span class="toc-text">SMT9.0 静态区间第 k 小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMT9-1-%20%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E5%8C%BA%E9%97%B4%E5%8A%A0%EF%BC%8C%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-text">SMT9.1 历史版本区间加，区间和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMT9-2-%20%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E5%8C%BA%E9%97%B4%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%8C%BA%E9%97%B4%E5%8A%A0"><span class="toc-text">SMT9.2 历史版本区间赋值，区间加</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">凸包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">李超线段树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">分块、莫队</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BB%B4%E8%8E%AB%E9%98%9F"><span class="toc-text">三维莫队</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">笛卡尔树</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/abe0ec5b.html" title="Map"><img src="/img/posts/music/monochrome_sense.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Map"></a><div class="content"><a class="title" href="/posts/abe0ec5b.html" title="Map">Map</a><time datetime="2026-02-13T16:00:00.000Z" title="更新於 2026-02-14 00:00:00">2026-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/31f676fd.html" title="〔主机註記〕第 105 周主机註記 (Feb.9 - Feb.15)"><img src="/img/zhuji-cover.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="〔主机註記〕第 105 周主机註記 (Feb.9 - Feb.15)"></a><div class="content"><a class="title" href="/posts/31f676fd.html" title="〔主机註記〕第 105 周主机註記 (Feb.9 - Feb.15)">〔主机註記〕第 105 周主机註記 (Feb.9 - Feb.15)</a><time datetime="2026-02-09T22:30:00.000Z" title="更新於 2026-02-10 06:30:00">2026-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9c43eea3.html" title="〔主机註記〕第 104 周主机註記 (Feb.2 - Feb.8)"><img src="/img/zhuji-cover.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="〔主机註記〕第 104 周主机註記 (Feb.2 - Feb.8)"></a><div class="content"><a class="title" href="/posts/9c43eea3.html" title="〔主机註記〕第 104 周主机註記 (Feb.2 - Feb.8)">〔主机註記〕第 104 周主机註記 (Feb.2 - Feb.8)</a><time datetime="2026-02-02T22:30:00.000Z" title="更新於 2026-02-03 06:30:00">2026-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/449a65b8.html" title="〔主机註記〕第 103 周主机註記 (Janu.26 - Feb.1)"><img src="/img/zhuji-cover.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="〔主机註記〕第 103 周主机註記 (Janu.26 - Feb.1)"></a><div class="content"><a class="title" href="/posts/449a65b8.html" title="〔主机註記〕第 103 周主机註記 (Janu.26 - Feb.1)">〔主机註記〕第 103 周主机註記 (Janu.26 - Feb.1)</a><time datetime="2026-01-26T22:30:00.000Z" title="更新於 2026-01-27 06:30:00">2026-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7cd85ddd.html" title="〔主机註記〕第 102 周主机註記 (Janu.19 - Janu.25)"><img src="/img/zhuji-cover.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="〔主机註記〕第 102 周主机註記 (Janu.19 - Janu.25)"></a><div class="content"><a class="title" href="/posts/7cd85ddd.html" title="〔主机註記〕第 102 周主机註記 (Janu.19 - Janu.25)">〔主机註記〕第 102 周主机註記 (Janu.19 - Janu.25)</a><time datetime="2026-01-19T22:30:00.000Z" title="更新於 2026-01-20 06:30:00">2026-01-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2026 By 小明同學</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"none"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const n=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],n),d=document.createTextNode("");e.parentNode.replaceChild(d,e),a.start={node:d,delim:"",n:0},a.end={node:d,delim:"",n:0},t.math.push(a)}},""]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{const o="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,t=null,e=(e=document,n=location.pathname)=>{twikoo.init({el:e.querySelector("#twikoo-wrap"),envId:"https://twikoo.kobicgend.top/",region:"ap-shanghai",onCommentLoaded:()=>{btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))},...t,path:n}),o&&(window.shuoshuoComment.destroyTwikoo=()=>{e.children.length&&(e.innerHTML="",e.classList.add("no-comment"))})},n=(o,t)=>{"object"==typeof twikoo?setTimeout(()=>e(o,t),0):btf.getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>e(o,t))};o?window.shuoshuoComment={loadComment:n}:n()})()</script></div><script src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script></body></html>